<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="description" content="ÊåØÂä®Á≥ªÁªüÁªºÂêàÊ®°ÊãüÂô® - ‰∫§‰∫íÂºèÁâ©ÁêÜÊïôÂ≠¶Â∑•ÂÖ∑ÔºåÂåÖÂê´ÁÆÄË∞êÊåØÂä®„ÄÅÈòªÂ∞ºÊåØÂä®ÂíåÂèóËø´ÊåØÂä®Ê®°ÊãüÔºåÂÆûÊó∂Âä®ÁîªÊºîÁ§∫ÂíåÊï∞ÊçÆÂàÜÊûê">
    <meta name="keywords" content="Áâ©ÁêÜÊ®°ÊãüÂô®,ÁÆÄË∞êÊåØÂä®,ÈòªÂ∞ºÊåØÂä®,ÂèóËø´ÊåØÂä®,ÂÖ±ÊåØ,Áâ©ÁêÜÊïôÂ≠¶,simple harmonic motion,damped oscillation,forced oscillation">
    <meta name="author" content="Physics Simulator">
    
    <!-- Open Graph Tags for Social Media -->
    <meta property="og:title" content="ÊåØÂä®Á≥ªÁªüÁªºÂêàÊ®°ÊãüÂô®">
    <meta property="og:description" content="‰∫§‰∫íÂºèÁâ©ÁêÜÊïôÂ≠¶Â∑•ÂÖ∑ - ÁÆÄË∞êÊåØÂä®„ÄÅÈòªÂ∞ºÊåØÂä®‰∏éÂèóËø´ÊåØÂä®ÂÆûÊó∂Ê®°Êãü">
    <meta property="og:type" content="website">
    <meta property="og:image" content="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='0.9em' font-size='90'>üéØ</text></svg>">
    
    <title>ÊåØÂä®Á≥ªÁªüÁªºÂêàÊ®°ÊãüÂô® | Oscillation System Simulator</title>
    
    <!-- Favicon -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='0.9em' font-size='90'>üéØ</text></svg>">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 100%;
            padding: 10px;
        }

        .header {
            text-align: center;
            color: white;
            padding: 15px 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header h1 {
            font-size: 24px;
            margin-bottom: 5px;
        }

        .header p {
            font-size: 14px;
            opacity: 0.9;
        }

        .simulator-selector {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 10px;
            margin: 15px auto;
            max-width: 600px;
            display: flex;
            gap: 10px;
        }

        .selector-btn {
            flex: 1;
            padding: 12px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border-radius: 10px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
        }

        .selector-btn.active {
            background: white;
            color: #764ba2;
            border-color: white;
            transform: scale(1.05);
        }

        .selector-btn:hover:not(.active) {
            background: rgba(255, 255, 255, 0.2);
        }

        .simulator-container {
            display: none;
        }

        .simulator-container.active {
            display: block;
        }

        .main-content {
            background: white;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            padding: 15px;
            margin-bottom: 20px;
        }

        .parameters-section {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .parameter-group {
            margin-bottom: 15px;
        }

        .parameter-group label {
            display: block;
            font-size: 14px;
            margin-bottom: 5px;
            color: #555;
            font-weight: 500;
        }

        .parameter-input {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .parameter-input input[type="range"] {
            flex: 1;
            -webkit-appearance: none;
            height: 6px;
            background: #ddd;
            border-radius: 3px;
            outline: none;
        }

        .parameter-input input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            cursor: pointer;
        }

        .parameter-input input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .parameter-input input[type="number"] {
            width: 70px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }

        .control-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .control-button {
            flex: 1;
            min-width: 100px;
            padding: 12px;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
        }

        .start-btn {
            background: linear-gradient(135deg, #00d2ff 0%, #3a7bd5 100%);
            color: white;
        }

        .pause-btn {
            background: linear-gradient(135deg, #f2994a 0%, #f2c94c 100%);
            color: white;
        }

        .reset-btn {
            background: linear-gradient(135deg, #ee5a24 0%, #f79f1f 100%);
            color: white;
        }

        .export-btn {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
        }

        .control-button:active {
            transform: scale(0.95);
        }

        .control-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .export-status {
            display: none;
            background: #e8f4f8;
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 15px;
            text-align: center;
            font-size: 14px;
            color: #333;
        }

        .export-status.active {
            display: block;
        }

        .export-status.recording {
            background: #ffe8e8;
            color: #d32f2f;
            font-weight: 600;
        }

        .export-status.processing {
            background: #fff3e0;
            color: #f57c00;
        }

        .export-status.success {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .info-section {
            background: #e8f4f8;
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 15px;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .info-label {
            font-weight: 600;
            color: #333;
        }

        .info-value {
            color: #666;
        }

        .animation-container {
            background: white;
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .animation-canvas {
            width: 100%;
            height: 250px;
            display: block;
        }

        .charts-section {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 15px;
        }

        .charts-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
        }

        .charts-title {
            font-size: 16px;
            font-weight: 600;
            color: #333;
        }

        .show-charts-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        .show-charts-btn:hover {
            transform: scale(1.05);
        }

        .charts-content {
            display: none;
        }

        .charts-content.active {
            display: block;
        }

        .tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }

        .tab-button {
            flex: 1;
            min-width: 80px;
            padding: 10px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 10px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
            white-space: nowrap;
        }

        .tab-button.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: transparent;
        }

        .charts-canvas-container {
            position: relative;
            width: 100%;
            height: 300px;
            background: white;
            border-radius: 10px;
            overflow: hidden;
        }

        .chart-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
            background: white;
            opacity: 0;
            transition: opacity 0.2s ease;
            pointer-events: none;
        }

        .chart-canvas.active {
            opacity: 1;
            pointer-events: auto;
        }

        .chart-canvas {
            width: 100%;
            height: 300px;
            display: block;
            background: white;
            border-radius: 10px;
            padding: 10px;
        }

        .speed-control {
            margin-top: 10px;
        }

        .section-divider {
            border-top: 2px solid #e0e0e0;
            margin: 15px 0;
            padding-top: 15px;
        }

        .section-title {
            font-size: 14px;
            font-weight: 600;
            color: #666;
            margin-bottom: 10px;
            display: block;
        }

        .footer {
            text-align: center;
            color: white;
            padding: 20px;
            font-size: 12px;
            opacity: 0.8;
        }

        .footer a {
            color: white;
            text-decoration: none;
            border-bottom: 1px solid rgba(255,255,255,0.5);
        }

        .footer a:hover {
            border-bottom-color: white;
        }

        /* ÈöêËóèÁöÑÁªÑÂêàÁîªÂ∏ÉÁî®‰∫éÂØºÂá∫ */
        #export-canvas {
            position: fixed;
            top: -9999px;
            left: -9999px;
            background: white;
        }

        @media (min-width: 768px) {
            .container {
                max-width: 768px;
                margin: 0 auto;
                padding: 20px;
            }

            .header h1 {
                font-size: 32px;
            }

            .animation-canvas {
                height: 350px;
            }

            .charts-canvas-container {
                height: 400px;
            }
        }

        .error-message {
            color: #e74c3c;
            text-align: center;
            padding: 10px;
            background: #ffe0e0;
            border-radius: 5px;
            margin: 10px 0;
            display: none;
        }

        /* Loading Animation */
        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }

        .loading::after {
            content: '';
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #ddd;
            border-radius: 50%;
            border-top-color: #667eea;
            animation: spin 1s linear infinite;
            margin-left: 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ÊåØÂä®Á≥ªÁªüÁªºÂêàÊ®°ÊãüÂô®</h1>
            <p>‰∫§‰∫íÂºèÁâ©ÁêÜÊïôÂ≠¶Â∑•ÂÖ∑ | Interactive Physics Teaching Tool</p>
        </div>

        <!-- Ê®°ÊãüÂô®ÈÄâÊã©Âô® -->
        <div class="simulator-selector">
            <button class="selector-btn active" onclick="switchSimulator('simple')">ÁÆÄË∞êÊåØÂä®</button>
            <button class="selector-btn" onclick="switchSimulator('damped')">ÈòªÂ∞ºÊåØÂä®</button>
            <button class="selector-btn" onclick="switchSimulator('forced')">ÂèóËø´ÊåØÂä®</button>
        </div>

        <!-- ÁÆÄË∞êÊåØÂä®Ê®°ÊãüÂô® -->
        <div id="simpleSimulator" class="simulator-container active">
            <div class="main-content">
                <!-- ÂèÇÊï∞ËÆæÁΩÆ -->
                <div class="parameters-section">
                    <div class="parameter-group">
                        <label>Ë¥®Èáè Mass (kg)</label>
                        <div class="parameter-input">
                            <input type="range" id="simple-massSlider" min="0.1" max="5" step="0.1" value="1">
                            <input type="number" id="simple-massInput" min="0.1" max="5" step="0.1" value="1">
                        </div>
                    </div>

                    <div class="parameter-group">
                        <label>ÂºπÁ∞ßÂ∏∏Êï∞ Spring Constant (N/m)</label>
                        <div class="parameter-input">
                            <input type="range" id="simple-springSlider" min="1" max="50" step="0.5" value="10">
                            <input type="number" id="simple-springInput" min="1" max="50" step="0.5" value="10">
                        </div>
                    </div>

                    <div class="parameter-group">
                        <label>ÂàùÂßã‰ΩçÁΩÆ Initial Position (m)</label>
                        <div class="parameter-input">
                            <input type="range" id="simple-positionSlider" min="-3" max="3" step="0.1" value="2">
                            <input type="number" id="simple-positionInput" min="-3" max="3" step="0.1" value="2">
                        </div>
                    </div>

                    <div class="parameter-group">
                        <label>ÂàùÂßãÈÄüÂ∫¶ Initial Velocity (m/s)</label>
                        <div class="parameter-input">
                            <input type="range" id="simple-velocitySlider" min="-5" max="5" step="0.1" value="0">
                            <input type="number" id="simple-velocityInput" min="-5" max="5" step="0.1" value="0">
                        </div>
                    </div>

                    <div class="parameter-group speed-control">
                        <label>Âä®ÁîªÈÄüÂ∫¶ Animation Speed</label>
                        <div class="parameter-input">
                            <input type="range" id="simple-speedSlider" min="0.1" max="3" step="0.1" value="1">
                            <span id="simple-speedDisplay">1.0x</span>
                        </div>
                    </div>
                </div>

                <!-- ÊéßÂà∂ÊåâÈíÆ -->
                <div class="control-buttons">
                    <button class="control-button start-btn" id="simple-startBtn">‚ñ∂ ÂºÄÂßã</button>
                    <button class="control-button pause-btn" id="simple-pauseBtn">‚è∏ ÊöÇÂÅú</button>
                    <button class="control-button reset-btn" id="simple-resetBtn">‚Ü∫ ÈáçÁΩÆ</button>
                    <button class="control-button export-btn" id="simple-exportBtn">üìπ ÂØºÂá∫ËßÜÈ¢ë</button>
                </div>

                <!-- ÂØºÂá∫Áä∂ÊÄÅÊèêÁ§∫ -->
                <div class="export-status" id="simple-exportStatus"></div>

                <!-- Á≥ªÁªü‰ø°ÊÅØ -->
                <div class="info-section">
                    <div class="info-item">
                        <span class="info-label">ËßíÈ¢ëÁéá:</span>
                        <span class="info-value" id="simple-angularFrequency">ËÆ°ÁÆó‰∏≠...</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">ÊåØÂä®È¢ëÁéá:</span>
                        <span class="info-value" id="simple-frequency">ËÆ°ÁÆó‰∏≠...</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">ÊåØÂä®Âë®Êúü:</span>
                        <span class="info-value" id="simple-period">ËÆ°ÁÆó‰∏≠...</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">ÊåØÂπÖ:</span>
                        <span class="info-value" id="simple-amplitude">ËÆ°ÁÆó‰∏≠...</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">ÊÄªËÉΩÈáè:</span>
                        <span class="info-value" id="simple-totalEnergy">ËÆ°ÁÆó‰∏≠...</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">ÂΩìÂâçÊó∂Èó¥:</span>
                        <span class="info-value" id="simple-currentTime">0.00 s</span>
                    </div>
                </div>

                <!-- ‰∏ªÂä®Áîª -->
                <div class="animation-container">
                    <canvas id="simple-animationCanvas" class="animation-canvas"></canvas>
                </div>

                <!-- ÂõæË°® -->
                <div class="charts-section">
                    <div class="charts-header">
                        <span class="charts-title">üìä ËØ¶ÁªÜÂõæË°®ÂàÜÊûê</span>
                        <button class="show-charts-btn" id="simple-toggleChartsBtn">ÊòæÁ§∫ÂõæË°®</button>
                    </div>
                    
                    <div class="charts-content" id="simple-chartsContent">
                        <div class="tabs">
                            <button class="tab-button active" data-tab="displacement">‰ΩçÁßª</button>
                            <button class="tab-button" data-tab="velocity">ÈÄüÂ∫¶</button>
                            <button class="tab-button" data-tab="energy">ËÉΩÈáè</button>
                            <button class="tab-button" data-tab="phase">Áõ∏‰ΩçÂõæ</button>
                        </div>

                        <div class="charts-canvas-container">
                            <canvas id="simple-displacementCanvas" class="chart-canvas active"></canvas>
                            <canvas id="simple-velocityCanvas" class="chart-canvas"></canvas>
                            <canvas id="simple-energyCanvas" class="chart-canvas"></canvas>
                            <canvas id="simple-phaseCanvas" class="chart-canvas"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ÈòªÂ∞ºÊåØÂä®Ê®°ÊãüÂô® -->
        <div id="dampedSimulator" class="simulator-container">
            <div class="main-content">
                <!-- ÂèÇÊï∞ËÆæÁΩÆ -->
                <div class="parameters-section">
                    <div class="parameter-group">
                        <label>Ë¥®Èáè Mass (kg)</label>
                        <div class="parameter-input">
                            <input type="range" id="damped-massSlider" min="0.1" max="5" step="0.1" value="1">
                            <input type="number" id="damped-massInput" min="0.1" max="5" step="0.1" value="1">
                        </div>
                    </div>

                    <div class="parameter-group">
                        <label>ÂºπÁ∞ßÂ∏∏Êï∞ Spring Constant (N/m)</label>
                        <div class="parameter-input">
                            <input type="range" id="damped-springSlider" min="1" max="50" step="0.5" value="10">
                            <input type="number" id="damped-springInput" min="1" max="50" step="0.5" value="10">
                        </div>
                    </div>

                    <div class="parameter-group">
                        <label>ÈòªÂ∞ºÁ≥ªÊï∞ Damping Coefficient (Ns/m)</label>
                        <div class="parameter-input">
                            <input type="range" id="damped-dampingSlider" min="0" max="10" step="0.1" value="0.5">
                            <input type="number" id="damped-dampingInput" min="0" max="10" step="0.1" value="0.5">
                        </div>
                    </div>

                    <div class="parameter-group">
                        <label>ÂàùÂßã‰ΩçÁΩÆ Initial Position (m)</label>
                        <div class="parameter-input">
                            <input type="range" id="damped-positionSlider" min="-3" max="3" step="0.1" value="2">
                            <input type="number" id="damped-positionInput" min="-3" max="3" step="0.1" value="2">
                        </div>
                    </div>

                    <div class="parameter-group">
                        <label>ÂàùÂßãÈÄüÂ∫¶ Initial Velocity (m/s)</label>
                        <div class="parameter-input">
                            <input type="range" id="damped-velocitySlider" min="-5" max="5" step="0.1" value="0">
                            <input type="number" id="damped-velocityInput" min="-5" max="5" step="0.1" value="0">
                        </div>
                    </div>

                    <div class="parameter-group speed-control">
                        <label>Âä®ÁîªÈÄüÂ∫¶ Animation Speed</label>
                        <div class="parameter-input">
                            <input type="range" id="damped-speedSlider" min="0.1" max="3" step="0.1" value="1">
                            <span id="damped-speedDisplay">1.0x</span>
                        </div>
                    </div>
                </div>

                <!-- ÊéßÂà∂ÊåâÈíÆ -->
                <div class="control-buttons">
                    <button class="control-button start-btn" id="damped-startBtn">‚ñ∂ ÂºÄÂßã</button>
                    <button class="control-button pause-btn" id="damped-pauseBtn">‚è∏ ÊöÇÂÅú</button>
                    <button class="control-button reset-btn" id="damped-resetBtn">‚Ü∫ ÈáçÁΩÆ</button>
                    <button class="control-button export-btn" id="damped-exportBtn">üìπ ÂØºÂá∫ËßÜÈ¢ë</button>
                </div>

                <!-- ÂØºÂá∫Áä∂ÊÄÅÊèêÁ§∫ -->
                <div class="export-status" id="damped-exportStatus"></div>

                <!-- Á≥ªÁªü‰ø°ÊÅØ -->
                <div class="info-section">
                    <div class="info-item">
                        <span class="info-label">ÈòªÂ∞ºÁ±ªÂûã:</span>
                        <span class="info-value" id="damped-dampingType">ËÆ°ÁÆó‰∏≠...</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">ÊåØÂä®È¢ëÁéá:</span>
                        <span class="info-value" id="damped-frequency">ËÆ°ÁÆó‰∏≠...</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">ÊåØÂä®Âë®Êúü:</span>
                        <span class="info-value" id="damped-period">ËÆ°ÁÆó‰∏≠...</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">ÂΩìÂâçÊó∂Èó¥:</span>
                        <span class="info-value" id="damped-currentTime">0.00 s</span>
                    </div>
                </div>

                <!-- ‰∏ªÂä®Áîª -->
                <div class="animation-container">
                    <canvas id="damped-animationCanvas" class="animation-canvas"></canvas>
                </div>

                <!-- ÂõæË°® -->
                <div class="charts-section">
                    <div class="charts-header">
                        <span class="charts-title">üìä ËØ¶ÁªÜÂõæË°®ÂàÜÊûê</span>
                        <button class="show-charts-btn" id="damped-toggleChartsBtn">ÊòæÁ§∫ÂõæË°®</button>
                    </div>
                    
                    <div class="charts-content" id="damped-chartsContent">
                        <div class="tabs">
                            <button class="tab-button active" data-tab="displacement">‰ΩçÁßª</button>
                            <button class="tab-button" data-tab="velocity">ÈÄüÂ∫¶</button>
                            <button class="tab-button" data-tab="energy">ËÉΩÈáè</button>
                        </div>

                        <div class="charts-canvas-container">
                            <canvas id="damped-displacementCanvas" class="chart-canvas active"></canvas>
                            <canvas id="damped-velocityCanvas" class="chart-canvas"></canvas>
                            <canvas id="damped-energyCanvas" class="chart-canvas"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ÂèóËø´ÊåØÂä®Ê®°ÊãüÂô® -->
        <div id="forcedSimulator" class="simulator-container">
            <div class="main-content">
                <!-- ÂèÇÊï∞ËÆæÁΩÆ -->
                <div class="parameters-section">
                    <span class="section-title">Á≥ªÁªüÂèÇÊï∞</span>
                    
                    <div class="parameter-group">
                        <label>Ë¥®Èáè Mass (kg)</label>
                        <div class="parameter-input">
                            <input type="range" id="forced-massSlider" min="0.1" max="5" step="0.1" value="1">
                            <input type="number" id="forced-massInput" min="0.1" max="5" step="0.1" value="1">
                        </div>
                    </div>

                    <div class="parameter-group">
                        <label>ÂºπÁ∞ßÂ∏∏Êï∞ Spring Constant (N/m)</label>
                        <div class="parameter-input">
                            <input type="range" id="forced-springSlider" min="1" max="50" step="0.5" value="10">
                            <input type="number" id="forced-springInput" min="1" max="50" step="0.5" value="10">
                        </div>
                    </div>

                    <div class="parameter-group">
                        <label>ÈòªÂ∞ºÁ≥ªÊï∞ Damping Coefficient (Ns/m)</label>
                        <div class="parameter-input">
                            <input type="range" id="forced-dampingSlider" min="0" max="5" step="0.1" value="0.5">
                            <input type="number" id="forced-dampingInput" min="0" max="5" step="0.1" value="0.5">
                        </div>
                    </div>

                    <div class="section-divider">
                        <span class="section-title">Â§ñÂäõÂèÇÊï∞</span>
                    </div>

                    <div class="parameter-group">
                        <label>Â§ñÂäõÂπÖÂÄº Force Amplitude (N)</label>
                        <div class="parameter-input">
                            <input type="range" id="forced-forceSlider" min="0" max="10" step="0.1" value="2">
                            <input type="number" id="forced-forceInput" min="0" max="10" step="0.1" value="2">
                        </div>
                    </div>

                    <div class="parameter-group">
                        <label>Â§ñÂäõÈ¢ëÁéá Force Frequency (rad/s)</label>
                        <div class="parameter-input">
                            <input type="range" id="forced-frequencySlider" min="0.1" max="10" step="0.1" value="3">
                            <input type="number" id="forced-frequencyInput" min="0.1" max="10" step="0.1" value="3">
                        </div>
                    </div>

                    <div class="section-divider">
                        <span class="section-title">ÂàùÂßãÊù°‰ª∂</span>
                    </div>

                    <div class="parameter-group">
                        <label>ÂàùÂßã‰ΩçÁΩÆ Initial Position (m)</label>
                        <div class="parameter-input">
                            <input type="range" id="forced-positionSlider" min="-3" max="3" step="0.1" value="0">
                            <input type="number" id="forced-positionInput" min="-3" max="3" step="0.1" value="0">
                        </div>
                    </div>

                    <div class="parameter-group">
                        <label>ÂàùÂßãÈÄüÂ∫¶ Initial Velocity (m/s)</label>
                        <div class="parameter-input">
                            <input type="range" id="forced-velocitySlider" min="-5" max="5" step="0.1" value="0">
                            <input type="number" id="forced-velocityInput" min="-5" max="5" step="0.1" value="0">
                        </div>
                    </div>

                    <div class="parameter-group speed-control">
                        <label>Âä®ÁîªÈÄüÂ∫¶ Animation Speed</label>
                        <div class="parameter-input">
                            <input type="range" id="forced-speedSlider" min="0.1" max="3" step="0.1" value="1">
                            <span id="forced-speedDisplay">1.0x</span>
                        </div>
                    </div>
                </div>

                <!-- ÊéßÂà∂ÊåâÈíÆ -->
                <div class="control-buttons">
                    <button class="control-button start-btn" id="forced-startBtn">‚ñ∂ ÂºÄÂßã</button>
                    <button class="control-button pause-btn" id="forced-pauseBtn">‚è∏ ÊöÇÂÅú</button>
                    <button class="control-button reset-btn" id="forced-resetBtn">‚Ü∫ ÈáçÁΩÆ</button>
                    <button class="control-button export-btn" id="forced-exportBtn">üìπ ÂØºÂá∫ËßÜÈ¢ë</button>
                </div>

                <!-- ÂØºÂá∫Áä∂ÊÄÅÊèêÁ§∫ -->
                <div class="export-status" id="forced-exportStatus"></div>

                <!-- Á≥ªÁªü‰ø°ÊÅØ -->
                <div class="info-section">
                    <div class="info-item">
                        <span class="info-label">Âõ∫ÊúâÈ¢ëÁéá:</span>
                        <span class="info-value" id="forced-naturalFrequency">ËÆ°ÁÆó‰∏≠...</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">È¢ëÁéáÊØî:</span>
                        <span class="info-value" id="forced-frequencyRatio">ËÆ°ÁÆó‰∏≠...</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Á®≥ÊÄÅÊåØÂπÖ:</span>
                        <span class="info-value" id="forced-steadyAmplitude">ËÆ°ÁÆó‰∏≠...</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Áõ∏‰ΩçÂ∑Æ:</span>
                        <span class="info-value" id="forced-phaseDifference">ËÆ°ÁÆó‰∏≠...</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">ÂΩìÂâçÊó∂Èó¥:</span>
                        <span class="info-value" id="forced-currentTime">0.00 s</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Â§ñÂäõ:</span>
                        <span class="info-value" id="forced-currentForce">0.00 N</span>
                    </div>
                </div>

                <!-- ‰∏ªÂä®Áîª -->
                <div class="animation-container">
                    <canvas id="forced-animationCanvas" class="animation-canvas"></canvas>
                </div>

                <!-- ÂõæË°® -->
                <div class="charts-section">
                    <div class="charts-header">
                        <span class="charts-title">üìä ËØ¶ÁªÜÂõæË°®ÂàÜÊûê</span>
                        <button class="show-charts-btn" id="forced-toggleChartsBtn">ÊòæÁ§∫ÂõæË°®</button>
                    </div>
                    
                    <div class="charts-content" id="forced-chartsContent">
                        <div class="tabs">
                            <button class="tab-button active" data-tab="displacement">‰ΩçÁßª</button>
                            <button class="tab-button" data-tab="velocity">ÈÄüÂ∫¶</button>
                            <button class="tab-button" data-tab="energy">ËÉΩÈáè</button>
                            <button class="tab-button" data-tab="resonance">ÂÖ±ÊåØÊõ≤Á∫ø</button>
                        </div>

                        <div class="charts-canvas-container">
                            <canvas id="forced-displacementCanvas" class="chart-canvas active"></canvas>
                            <canvas id="forced-velocityCanvas" class="chart-canvas"></canvas>
                            <canvas id="forced-energyCanvas" class="chart-canvas"></canvas>
                            <canvas id="forced-resonanceCanvas" class="chart-canvas"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Footer -->
        <div class="footer">
            <p>¬© 2025 ÊåØÂä®Á≥ªÁªüÁªºÂêàÊ®°ÊãüÂô® | Created with ‚ù§Ô∏è for Physics Education</p>
            <p>
                <a href="https://github.com" target="_blank">View on GitHub</a> | 
                <a href="mailto:contact@example.com">Contact</a>
            </p>
        </div>
    </div>

    <!-- ÈöêËóèÁöÑÂØºÂá∫ÁîªÂ∏É -->
    <canvas id="export-canvas"></canvas>

    <script>
        // ============================================
        // ÊåØÂä®Á≥ªÁªüÁªºÂêàÊ®°ÊãüÂô® - ÂÆåÊï¥JavaScript‰ª£Á†Å
        // ============================================
        
        // ÂΩìÂâçÊ¥ªÂä®ÁöÑÊ®°ÊãüÂô®
        let currentSimulator = 'simple';

        // ËßÜÈ¢ëÂØºÂá∫Â∑•ÂÖ∑Á±ª
        class VideoExporter {
            constructor(simulatorType) {
                this.simulatorType = simulatorType;
                this.exportCanvas = null;
                this.exportCtx = null;
                this.mediaRecorder = null;
                this.recordedChunks = [];
                this.isRecording = false;
                this.isMobile = this.checkMobile();
            }

            // Ê£ÄÊµãÊòØÂê¶‰∏∫ÁßªÂä®ËÆæÂ§á
            checkMobile() {
                return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            }

            // Ê£ÄÊµãÊµèËßàÂô®ÂÖºÂÆπÊÄß
            checkCompatibility() {
                // Ê£ÄÊü• MediaRecorder API ÊîØÊåÅ
                if (!window.MediaRecorder) {
                    throw new Error('ÊÇ®ÁöÑÊµèËßàÂô®‰∏çÊîØÊåÅËßÜÈ¢ëÂΩïÂà∂ÂäüËÉΩÔºåËØ∑‰ΩøÁî®Chrome„ÄÅFirefoxÊàñSafariÁ≠âÁé∞‰ª£ÊµèËßàÂô®');
                }
                
                // Ê£ÄÊü•ÊîØÊåÅÁöÑÁºñÁ†ÅÊ†ºÂºè
                const types = [
                    'video/webm;codecs=vp9',
                    'video/webm;codecs=vp8',
                    'video/webm',
                    'video/mp4'
                ];
                
                for (const type of types) {
                    if (MediaRecorder.isTypeSupported(type)) {
                        return type;
                    }
                }
                
                throw new Error('ÊÇ®ÁöÑÊµèËßàÂô®‰∏çÊîØÊåÅÊâÄÈúÄÁöÑËßÜÈ¢ëÊ†ºÂºè');
            }

            // ÂàõÂª∫Âçï‰∏™ËßÜÂõæÁöÑÁîªÂ∏ÉÔºàÁßªÂä®Á´Ø‰ºòÂåñÔºâ
            createSingleViewCanvas(viewType) {
                const exportCanvas = document.getElementById('export-canvas');
                
                // Ê†πÊçÆËÆæÂ§áÁ±ªÂûãÂíåËßÜÂõæÁ±ªÂûãËÆæÁΩÆÁîªÂ∏ÉÂ∞∫ÂØ∏
                let width, height;
                if (this.isMobile) {
                    // ÁßªÂä®Á´Ø‰ΩøÁî®ËæÉÂ∞èÂàÜËæ®Áéá‰ª•ÊèêÈ´òÊÄßËÉΩ
                    if (viewType === 'animation') {
                        width = 854;
                        height = 480;
                    } else {
                        width = 1280;
                        height = 720;
                    }
                } else {
                    // Ê°åÈù¢Á´Ø‰øùÊåÅÈ´òÂàÜËæ®Áéá
                    if (viewType === 'animation') {
                        width = 1280;
                        height = 720;
                    } else {
                        width = 1920;
                        height = 1080;
                    }
                }
                
                exportCanvas.width = width;
                exportCanvas.height = height;
                
                this.exportCanvas = exportCanvas;
                this.exportCtx = exportCanvas.getContext('2d', {
                    // ‰ºòÂåñÊÄßËÉΩÁöÑËÆæÁΩÆ
                    alpha: false,
                    desynchronized: true
                });
                
                // ËÆæÁΩÆÁôΩËâ≤ËÉåÊôØ
                this.exportCtx.fillStyle = 'white';
                this.exportCtx.fillRect(0, 0, width, height);
                
                return exportCanvas;
            }

            // ÂØºÂá∫ÊâÄÊúâËßÜÈ¢ëÔºàÁßªÂä®Á´Ø‰ºòÂåñÔºâ
            async exportAllVideos(sim) {
                const videos = ['animation', 'displacement', 'velocity', 'energy'];
                if (this.simulatorType === 'simple') {
                    videos.push('phase');
                } else if (this.simulatorType === 'forced') {
                    videos.push('resonance');
                }
                
                // ÁßªÂä®Á´ØÈÄê‰∏™ÂØºÂá∫ÔºåÈÅøÂÖçÂÜÖÂ≠òÊ∫¢Âá∫
                for (const videoType of videos) {
                    await this.exportSingleVideo(sim, videoType);
                    // Á≠âÂæÖÊõ¥ÈïøÊó∂Èó¥ÔºåËÆ©ÁßªÂä®ËÆæÂ§áÊúâÊó∂Èó¥Â§ÑÁêÜ
                    await new Promise(resolve => setTimeout(resolve, this.isMobile ? 1000 : 500));
                    
                    // ÁßªÂä®Á´ØÊ∏ÖÁêÜÂÜÖÂ≠ò
                    if (this.isMobile && typeof window.gc === 'function') {
                        window.gc();
                    }
                }
            }

            // ÂØºÂá∫Âçï‰∏™ËßÜÈ¢ëÔºàÁßªÂä®Á´Ø‰ºòÂåñÔºâ
            async exportSingleVideo(sim, viewType) {
                try {
                    // Ê£ÄÊü•ÂÖºÂÆπÊÄß
                    const mimeType = this.checkCompatibility();
                    
                    // ÂàõÂª∫ÂØπÂ∫îËßÜÂõæÁöÑÁîªÂ∏É
                    this.createSingleViewCanvas(viewType);
                    
                    // ËÆ°ÁÆóÂΩïÂà∂Êó∂ÈïøÔºàÁßªÂä®Á´ØÁº©Áü≠Ôºâ
                    const recordingDuration = this.calculateRecordingDuration(sim, viewType);
                    
                    // ÂºÄÂßãÂΩïÂà∂
                    await this.startRecording(sim, mimeType);
                    
                    // ÂΩïÂà∂Â∏ßÔºàÁßªÂä®Á´ØÈôç‰ΩéÂ∏ßÁéáÔºâ
                    const fps = this.isMobile ? 15 : 30;
                    const totalFrames = Math.ceil(recordingDuration * fps);
                    
                    for (let frameNum = 0; frameNum < totalFrames; frameNum++) {
                        const progress = frameNum / totalFrames;
                        const currentDataTime = progress * recordingDuration;
                        const dataIndex = Math.floor(currentDataTime / 0.05);
                        
                        if (dataIndex < sim.data.time.length) {
                            this.drawSingleViewFrame(sim, viewType, dataIndex);
                        }
                        
                        await new Promise(resolve => setTimeout(resolve, 1000 / fps));
                        
                        // ÁßªÂä®Á´ØÂÆöÊúüËÆ©Âá∫ÊéßÂà∂ÊùÉ
                        if (this.isMobile && frameNum % 30 === 0) {
                            await new Promise(resolve => setTimeout(resolve, 10));
                        }
                    }
                    
                    // ÂÅúÊ≠¢ÂΩïÂà∂Âπ∂‰øùÂ≠ò
                    this.stopRecording();
                    await new Promise(resolve => setTimeout(resolve, 100));
                    this.saveVideo(sim, viewType);
                    
                } catch (error) {
                    // Ê∏ÖÁêÜËµÑÊ∫ê
                    this.stopRecording();
                    throw error;
                }
            }

            // ËÆ°ÁÆóÂΩïÂà∂Êó∂ÈïøÔºàÁßªÂä®Á´Ø‰ºòÂåñÔºâ
            calculateRecordingDuration(sim, viewType) {
                if (viewType === 'phase' || viewType === 'resonance') {
                    // Áõ∏‰ΩçÂõæÂíåÂÖ±ÊåØÊõ≤Á∫øÂΩïÂà∂ËæÉÁü≠Êó∂Èó¥
                    return this.isMobile ? 3 : 5;
                }
                
                // ÂÖ∂‰ªñËßÜÂõæÂΩïÂà∂ÂÆåÊï¥Êï∞ÊçÆÊàñÊúÄÂ§öÊó∂Èó¥ÔºàÁßªÂä®Á´ØÁº©Áü≠Ôºâ
                const totalDataTime = sim.data.time[sim.data.time.length - 1];
                const maxDuration = this.isMobile ? 10 : 20;
                return Math.min(totalDataTime, maxDuration);
            }

            // ÂºÄÂßãÂΩïÂà∂ÔºàÊîπËøõÁöÑÂÖºÂÆπÊÄßÔºâ
            async startRecording(sim, mimeType) {
                return new Promise((resolve, reject) => {
                    try {
                        // ÂàõÂª∫ÊµÅ
                        const stream = this.exportCanvas.captureStream(this.isMobile ? 15 : 30);
                        
                        // ÈÖçÁΩÆÈÄâÈ°πÔºàÁßªÂä®Á´Ø‰ºòÂåñÔºâ
                        const options = {
                            mimeType: mimeType
                        };
                        
                        // Ê†πÊçÆËÆæÂ§áË∞ÉÊï¥ÊØîÁâπÁéá
                        if (mimeType.includes('webm')) {
                            options.videoBitsPerSecond = this.isMobile ? 2000000 : 8000000; // ÁßªÂä®Á´Ø2MbpsÔºåÊ°åÈù¢Á´Ø8Mbps
                        }
                        
                        // ÂàõÂª∫Â™í‰ΩìÂΩïÂà∂Âô®
                        this.mediaRecorder = new MediaRecorder(stream, options);
                        
                        this.recordedChunks = [];
                        
                        this.mediaRecorder.ondataavailable = (event) => {
                            if (event.data && event.data.size > 0) {
                                this.recordedChunks.push(event.data);
                            }
                        };
                        
                        this.mediaRecorder.onerror = (error) => {
                            console.error('ÂΩïÂà∂ÈîôËØØ:', error);
                            reject(error);
                        };
                        
                        this.mediaRecorder.onstop = () => {
                            // ÂÅúÊ≠¢Êó∂ÁöÑÂ§ÑÁêÜÂú®Â§ñÈÉ®ËøõË°å
                        };
                        
                        // ÂºÄÂßãÂΩïÂà∂ÔºàÁßªÂä®Á´Ø‰ΩøÁî®Êó∂Èó¥Áâá‰ª•ÂáèÂ∞ëÂÜÖÂ≠ò‰ΩøÁî®Ôºâ
                        if (this.isMobile) {
                            this.mediaRecorder.start(1000); // ÊØèÁßíÁîüÊàê‰∏Ä‰∏™Êï∞ÊçÆÂùó
                        } else {
                            this.mediaRecorder.start();
                        }
                        
                        this.isRecording = true;
                        resolve();
                    } catch (error) {
                        reject(error);
                    }
                });
            }

            // ‰øùÂ≠òËßÜÈ¢ëÔºàÊîπËøõÁöÑÂÖºÂÆπÊÄßÔºâ
            saveVideo(sim, viewType) {
                try {
                    const blob = new Blob(this.recordedChunks, { 
                        type: this.recordedChunks.length > 0 ? this.recordedChunks[0].type : 'video/webm' 
                    });
                    
                    const url = URL.createObjectURL(blob);
                    
                    const a = document.createElement('a');
                    a.href = url;
                    
                    let fileName = 'oscillation_';
                    if (this.simulatorType === 'simple') {
                        fileName += 'simple_';
                    } else if (this.simulatorType === 'damped') {
                        fileName += 'damped_';
                    } else {
                        fileName += 'forced_';
                    }
                    
                    // Ê∑ªÂä†ËßÜÂõæÁ±ªÂûã
                    fileName += viewType + '_';
                    
                    const date = new Date();
                    fileName += `${date.getFullYear()}${String(date.getMonth()+1).padStart(2,'0')}${String(date.getDate()).padStart(2,'0')}`;
                    fileName += `_${String(date.getHours()).padStart(2,'0')}${String(date.getMinutes()).padStart(2,'0')}${String(date.getSeconds()).padStart(2,'0')}`;
                    
                    // Ê†πÊçÆÂÆûÈôÖÁ±ªÂûãËÆæÁΩÆÊñá‰ª∂Êâ©Â±ïÂêç
                    const extension = blob.type.includes('mp4') ? '.mp4' : '.webm';
                    fileName += extension;
                    
                    a.download = fileName;
                    
                    // ÁßªÂä®Á´ØÁâπÊÆäÂ§ÑÁêÜ
                    if (this.isMobile) {
                        // iOSËÆæÂ§áÈúÄË¶ÅÁâπÊÆäÂ§ÑÁêÜ
                        if (/iPad|iPhone|iPod/.test(navigator.userAgent)) {
                            // Â∞ùËØïÁõ¥Êé•ÊâìÂºÄËßÜÈ¢ë
                            window.open(url, '_blank');
                        } else {
                            // AndroidÂíåÂÖ∂‰ªñËÆæÂ§á
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                        }
                    } else {
                        // Ê°åÈù¢Á´ØÊ†áÂáÜ‰∏ãËΩΩ
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                    }
                    
                    // Âª∂ËøüÊ∏ÖÁêÜURLÔºåÁ°Æ‰øù‰∏ãËΩΩÂÆåÊàê
                    setTimeout(() => {
                        URL.revokeObjectURL(url);
                    }, 5000);
                    
                    // Ê∏ÖÁêÜÂÜÖÂ≠ò
                    this.recordedChunks = [];
                    
                } catch (error) {
                    console.error('‰øùÂ≠òËßÜÈ¢ëÂ§±Ë¥•:', error);
                    throw new Error('‰øùÂ≠òËßÜÈ¢ëÂ§±Ë¥•ÔºåËØ∑ÈáçËØï');
                }
            }

            // ÁªòÂà∂Âçï‰∏™ËßÜÂõæÁöÑÂ∏ß
            drawSingleViewFrame(sim, viewType, frameIndex) {
                const ctx = this.exportCtx;
                const width = this.exportCanvas.width;
                const height = this.exportCanvas.height;
                
                // Ê∏ÖÈô§ÁîªÂ∏É
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, width, height);
                
                // Ê†áÈ¢ò
                ctx.fillStyle = '#333';
                ctx.font = 'bold 36px Arial';
                ctx.textAlign = 'center';
                
                let title = '';
                if (this.simulatorType === 'simple') {
                    title = 'ÁÆÄË∞êÊåØÂä® - ';
                } else if (this.simulatorType === 'damped') {
                    title = 'ÈòªÂ∞ºÊåØÂä® - ';
                } else {
                    title = 'ÂèóËø´ÊåØÂä® - ';
                }
                
                switch(viewType) {
                    case 'animation':
                        title += 'Á≥ªÁªüÂä®Áîª';
                        break;
                    case 'displacement':
                        title += '‰ΩçÁßª-Êó∂Èó¥Âõæ';
                        break;
                    case 'velocity':
                        title += 'ÈÄüÂ∫¶-Êó∂Èó¥Âõæ';
                        break;
                    case 'energy':
                        title += 'ËÉΩÈáè-Êó∂Èó¥Âõæ';
                        break;
                    case 'phase':
                        title += 'Áõ∏‰ΩçÂõæ';
                        break;
                    case 'resonance':
                        title += 'ÂÖ±ÊåØÊõ≤Á∫ø';
                        break;
                }
                
                ctx.fillText(title, width / 2, 60);
                
                // Êó∂Èó¥‰ø°ÊÅØ
                const currentTime = sim.data.time[frameIndex] || 0;
                ctx.font = '24px Arial';
                ctx.fillText(`t = ${currentTime.toFixed(2)} s`, width / 2, 100);
                
                // Ê†πÊçÆËßÜÂõæÁ±ªÂûãÁªòÂà∂ÂÜÖÂÆπ
                if (viewType === 'animation') {
                    // ‰∏ªÂä®Áîª
                    this.drawMainAnimationFrame(sim, frameIndex, 50, 140, width - 100, height - 240);
                    
                    // ÂèÇÊï∞‰ø°ÊÅØ
                    this.drawParameterInfo(sim, frameIndex, 50, height - 80, width - 100, 60);
                } else {
                    // ÂõæË°®ËßÜÂõæ
                    const chartX = 80;
                    const chartY = 140;
                    const chartWidth = width - 160;
                    const chartHeight = height - 280;
                    
                    ctx.strokeStyle = '#ddd';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(chartX, chartY, chartWidth, chartHeight);
                    
                    if (viewType === 'phase' || viewType === 'resonance') {
                        // ÈùôÊÄÅÂõæË°®
                        this.drawStaticChart(sim, viewType, frameIndex, chartX, chartY, chartWidth, chartHeight);
                    } else {
                        // ÊªöÂä®ÂõæË°®
                        this.drawScrollingChartFull(sim, viewType, frameIndex, chartX, chartY, chartWidth, chartHeight);
                    }
                    
                    // ÂèÇÊï∞‰ø°ÊÅØ
                    this.drawParameterInfo(sim, frameIndex, 50, height - 80, width - 100, 60);
                }
            }

            // ÁªòÂà∂ÂÆåÊï¥ÁöÑÊªöÂä®ÂõæË°®ÔºàÁî®‰∫éÂçïÁã¨ÂØºÂá∫Ôºâ
            drawScrollingChartFull(sim, chartType, currentIndex, x, y, width, height) {
                const ctx = this.exportCtx;
                
                ctx.save();
                ctx.translate(x, y);
                
                // ËÉåÊôØ
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, width, height);
                
                // ÂùêÊ†áËΩ¥
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(60, height - 60);
                ctx.lineTo(width - 40, height - 60);
                ctx.moveTo(60, height - 60);
                ctx.lineTo(60, 40);
                ctx.stroke();
                
                // ÂùêÊ†áËΩ¥Ê†áÁ≠æ
                ctx.font = '18px Arial';
                ctx.fillStyle = '#333';
                ctx.textAlign = 'center';
                ctx.fillText('Êó∂Èó¥ (s)', width / 2, height - 20);
                
                ctx.save();
                ctx.translate(25, height / 2);
                ctx.rotate(-Math.PI / 2);
                
                if (chartType === 'displacement') {
                    ctx.fillText('‰ΩçÁßª (m)', 0, 0);
                } else if (chartType === 'velocity') {
                    ctx.fillText('ÈÄüÂ∫¶ (m/s)', 0, 0);
                } else if (chartType === 'energy') {
                    ctx.fillText('ËÉΩÈáè (J)', 0, 0);
                }
                ctx.restore();
                
                // ÁªòÂà∂Êï∞ÊçÆ
                const plotX = 60;
                const plotY = 40;
                const plotWidth = width - 100;
                const plotHeight = height - 100;
                
                // ÈáçË¶ÅÔºöÂè™ÁªòÂà∂Âà∞ÂΩìÂâçÁ¥¢ÂºïÔºå‰∏çÁªòÂà∂Êú™Êù•ÁöÑÊï∞ÊçÆ
                const dataEndIndex = Math.min(currentIndex + 1, sim.data.time.length);
                
                if (chartType === 'displacement') {
                    // ‰ΩçÁßªÊõ≤Á∫ø - Âè™ÁªòÂà∂Âà∞ÂΩìÂâçÊó∂Âàª
                    this.drawProgressiveLine(sim.data.time.slice(0, dataEndIndex),
                                           sim.data.position.slice(0, dataEndIndex),
                                           '#3498db', currentIndex,
                                           plotX, plotY, plotWidth, plotHeight, 3);
                    
                    // Â¶ÇÊûúÊòØÂèóËø´ÊåØÂä®ÔºåÁªòÂà∂Â§ñÂäõ
                    if (this.simulatorType === 'forced') {
                        const scaledForce = sim.data.force.slice(0, dataEndIndex).map(f => f * 0.3);
                        this.drawProgressiveLine(sim.data.time.slice(0, dataEndIndex),
                                               scaledForce, '#27ae60', -1,
                                               plotX, plotY, plotWidth, plotHeight, 2);
                        
                        // Âõæ‰æã
                        ctx.font = '16px Arial';
                        ctx.textAlign = 'left';
                        ctx.fillStyle = '#3498db';
                        ctx.fillRect(width - 180, 60, 20, 20);
                        ctx.fillStyle = '#333';
                        ctx.fillText('‰ΩçÁßª', width - 150, 77);
                        
                        ctx.fillStyle = '#27ae60';
                        ctx.fillRect(width - 180, 90, 20, 20);
                        ctx.fillStyle = '#333';
                        ctx.fillText('Â§ñÂäõ√ó0.3', width - 150, 107);
                    }
                    
                } else if (chartType === 'velocity') {
                    // ÈÄüÂ∫¶Êõ≤Á∫ø - Âè™ÁªòÂà∂Âà∞ÂΩìÂâçÊó∂Âàª
                    this.drawProgressiveLine(sim.data.time.slice(0, dataEndIndex),
                                           sim.data.velocity.slice(0, dataEndIndex),
                                           '#e74c3c', currentIndex,
                                           plotX, plotY, plotWidth, plotHeight, 3);
                    
                } else if (chartType === 'energy') {
                    // ËÉΩÈáèÊõ≤Á∫ø - Âè™ÁªòÂà∂Âà∞ÂΩìÂâçÊó∂Âàª
                    this.drawProgressiveLine(sim.data.time.slice(0, dataEndIndex),
                                           sim.data.kineticEnergy.slice(0, dataEndIndex),
                                           '#e74c3c', -1,
                                           plotX, plotY, plotWidth, plotHeight, 2);
                    
                    this.drawProgressiveLine(sim.data.time.slice(0, dataEndIndex),
                                           sim.data.potentialEnergy.slice(0, dataEndIndex),
                                           '#3498db', -1,
                                           plotX, plotY, plotWidth, plotHeight, 2);
                    
                    this.drawProgressiveLine(sim.data.time.slice(0, dataEndIndex),
                                           sim.data.totalEnergy.slice(0, dataEndIndex),
                                           '#2c3e50', -1,
                                           plotX, plotY, plotWidth, plotHeight, 2);
                    
                    // Âõæ‰æã
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillStyle = '#e74c3c';
                    ctx.fillRect(width - 150, 60, 20, 20);
                    ctx.fillStyle = '#333';
                    ctx.fillText('Âä®ËÉΩ', width - 120, 77);
                    
                    ctx.fillStyle = '#3498db';
                    ctx.fillRect(width - 150, 90, 20, 20);
                    ctx.fillStyle = '#333';
                    ctx.fillText('ÂäøËÉΩ', width - 120, 107);
                    
                    ctx.fillStyle = '#2c3e50';
                    ctx.fillRect(width - 150, 120, 20, 20);
                    ctx.fillStyle = '#333';
                    ctx.fillText('ÊÄªËÉΩÈáè', width - 120, 137);
                }
                
                ctx.restore();
            }

            // ÁªòÂà∂Ê∏êËøõÂºèÁ∫øÊù°ÔºàÊ®°Êãü‰∏ªÁïåÈù¢ÁöÑÈÄêÊ≠•ÁªòÂà∂ÊïàÊûúÔºâ
            drawProgressiveLine(xData, yData, color, markerIndex, x, y, width, height, lineWidth = 2) {
                const ctx = this.exportCtx;
                
                if (xData.length === 0 || yData.length === 0) return;
                
                // ËÆ°ÁÆóÊï∞ÊçÆËåÉÂõ¥Ôºà‰ΩøÁî®ÂÆåÊï¥Êï∞ÊçÆËåÉÂõ¥‰ª•‰øùÊåÅÊØî‰æã‰∏ÄËá¥Ôºâ
                const xMin = 0;
                const xMax = 20; // ‰ΩøÁî®Âõ∫ÂÆöÁöÑÊó∂Èó¥ËåÉÂõ¥
                const yMin = Math.min(...yData);
                const yMax = Math.max(...yData);
                
                // ÁªòÂà∂Â∑≤ÊúâÁöÑÁ∫øÊù°
                ctx.strokeStyle = color;
                ctx.lineWidth = lineWidth;
                ctx.beginPath();
                
                for (let i = 0; i < xData.length; i++) {
                    const px = x + (xData[i] - xMin) / (xMax - xMin) * width;
                    const py = y + height - (yData[i] - yMin) / (yMax - yMin) * height;
                    
                    if (i === 0) {
                        ctx.moveTo(px, py);
                    } else {
                        ctx.lineTo(px, py);
                    }
                }
                ctx.stroke();
                
                // Âú®ÊúÄÂêé‰∏Ä‰∏™ÁÇπÂ§ÑÁªòÂà∂Ê†áËÆ∞
                if (markerIndex >= 0 && markerIndex < xData.length) {
                    const lastIndex = xData.length - 1;
                    const px = x + (xData[lastIndex] - xMin) / (xMax - xMin) * width;
                    const py = y + height - (yData[lastIndex] - yMin) / (yMax - yMin) * height;
                    
                    ctx.fillStyle = '#ff6b35';
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(px, py, 8, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                }
            }

            // ÁªòÂà∂ÈùôÊÄÅÂõæË°®ÔºàÁõ∏‰ΩçÂõæÂíåÂÖ±ÊåØÊõ≤Á∫øÔºâ
            drawStaticChart(sim, chartType, currentIndex, x, y, width, height) {
                const ctx = this.exportCtx;
                
                ctx.save();
                ctx.translate(x, y);
                
                // ËÉåÊôØ
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, width, height);
                
                if (chartType === 'phase') {
                    // Áõ∏‰ΩçÂõæ
                    this.drawPhaseChart(sim, currentIndex, width, height);
                } else if (chartType === 'resonance') {
                    // ÂÖ±ÊåØÊõ≤Á∫ø
                    this.drawResonanceChart(sim, width, height);
                }
                
                ctx.restore();
            }

            // ÁªòÂà∂Áõ∏‰ΩçÂõæ
            drawPhaseChart(sim, currentIndex, width, height) {
                const ctx = this.exportCtx;
                
                // ÂùêÊ†áËΩ¥
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(width / 2, 40);
                ctx.lineTo(width / 2, height - 40);
                ctx.moveTo(60, height / 2);
                ctx.lineTo(width - 60, height / 2);
                ctx.stroke();
                
                // Ê†áÁ≠æ
                ctx.fillStyle = '#333';
                ctx.font = '18px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('‰ΩçÁßª (m)', width - 100, height / 2 - 15);
                ctx.save();
                ctx.translate(width / 2 + 20, 60);
                ctx.fillText('ÈÄüÂ∫¶ (m/s)', 0, 0);
                ctx.restore();
                
                // ÁªòÂà∂Áõ∏‰ΩçËΩ®Ëøπ
                const xMin = Math.min(...sim.data.position);
                const xMax = Math.max(...sim.data.position);
                const vMin = Math.min(...sim.data.velocity);
                const vMax = Math.max(...sim.data.velocity);
                
                const scale = 0.8;
                
                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 3;
                ctx.beginPath();
                
                for (let i = 0; i <= currentIndex && i < sim.data.position.length; i++) {
                    const px = width / 2 + (sim.data.position[i] / Math.max(Math.abs(xMin), Math.abs(xMax))) * (width * scale / 2 - 80);
                    const py = height / 2 - (sim.data.velocity[i] / Math.max(Math.abs(vMin), Math.abs(vMax))) * (height * scale / 2 - 80);
                    
                    if (i === 0) {
                        ctx.moveTo(px, py);
                    } else {
                        ctx.lineTo(px, py);
                    }
                }
                ctx.stroke();
                
                // Ê†áËÆ∞ÂΩìÂâçÁÇπ
                if (currentIndex < sim.data.position.length) {
                    const px = width / 2 + (sim.data.position[currentIndex] / Math.max(Math.abs(xMin), Math.abs(xMax))) * (width * scale / 2 - 80);
                    const py = height / 2 - (sim.data.velocity[currentIndex] / Math.max(Math.abs(vMin), Math.abs(vMax))) * (height * scale / 2 - 80);
                    
                    ctx.fillStyle = '#ff6b35';
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(px, py, 8, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                }
            }

            // ÁªòÂà∂ÂÖ±ÊåØÊõ≤Á∫ø
            drawResonanceChart(sim, width, height) {
                const ctx = this.exportCtx;
                
                // ÂùêÊ†áËΩ¥
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(60, height - 60);
                ctx.lineTo(width - 40, height - 60);
                ctx.moveTo(60, height - 60);
                ctx.lineTo(60, 40);
                ctx.stroke();
                
                // Ê†áÁ≠æ
                ctx.fillStyle = '#333';
                ctx.font = '18px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('È¢ëÁéáÊØî (œâ/œân)', width / 2, height - 20);
                
                ctx.save();
                ctx.translate(25, height / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText('ÊåØÂπÖ (m)', 0, 0);
                ctx.restore();
                
                // ÁªòÂà∂ÂÖ±ÊåØÊõ≤Á∫ø
                const omega_n = Math.sqrt(sim.params.springConstant / sim.params.mass);
                const frequencyRatios = sim.resonanceData.frequencies.map(f => f / omega_n);
                
                const xMin = Math.min(...frequencyRatios);
                const xMax = Math.max(...frequencyRatios);
                const yMin = Math.min(...sim.resonanceData.amplitudes);
                const yMax = Math.max(...sim.resonanceData.amplitudes);
                
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 3;
                ctx.beginPath();
                
                for (let i = 0; i < frequencyRatios.length; i++) {
                    const px = 60 + (frequencyRatios[i] - xMin) / (xMax - xMin) * (width - 100);
                    const py = height - 60 - (sim.resonanceData.amplitudes[i] - yMin) / (yMax - yMin) * (height - 100);
                    
                    if (i === 0) {
                        ctx.moveTo(px, py);
                    } else {
                        ctx.lineTo(px, py);
                    }
                }
                ctx.stroke();
                
                // Ê†áËÆ∞ÂΩìÂâçÂ∑•‰ΩúÁÇπ
                const currentRatio = sim.params.forceFrequency / omega_n;
                const denominator = Math.sqrt(Math.pow(sim.params.springConstant - sim.params.mass * sim.params.forceFrequency * sim.params.forceFrequency, 2) + 
                                             Math.pow(sim.params.dampingCoefficient * sim.params.forceFrequency, 2));
                const currentAmplitude = sim.params.forceAmplitude / denominator;
                
                const px = 60 + (currentRatio - xMin) / (xMax - xMin) * (width - 100);
                const py = height - 60 - (currentAmplitude - yMin) / (yMax - yMin) * (height - 100);
                
                ctx.fillStyle = '#27ae60';
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(px, py, 8, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
                
                // ÂÖ±ÊåØÈ¢ëÁéáÁ∫ø
                ctx.strokeStyle = '#95a5a6';
                ctx.lineWidth = 2;
                ctx.setLineDash([8, 8]);
                ctx.beginPath();
                const resonanceX = 60 + (1 - xMin) / (xMax - xMin) * (width - 100);
                ctx.moveTo(resonanceX, 40);
                ctx.lineTo(resonanceX, height - 60);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Âõæ‰æã
                ctx.font = '16px Arial';
                ctx.textAlign = 'left';
                ctx.fillStyle = '#27ae60';
                ctx.fillRect(width - 180, 60, 20, 20);
                ctx.fillStyle = '#333';
                ctx.fillText('ÂΩìÂâçÂ∑•‰ΩúÁÇπ', width - 150, 77);
            }

            // ÁªòÂà∂Á∫øÊù°ÔºàÊîπËøõÁâàÔºâ
            drawLine(xData, yData, color, xMin, xMax, markerIndex, x, y, width, height, lineWidth = 2) {
                const ctx = this.exportCtx;
                
                if (xData.length === 0 || yData.length === 0) return;
                
                const yMin = Math.min(...yData);
                const yMax = Math.max(...yData);
                
                ctx.strokeStyle = color;
                ctx.lineWidth = lineWidth;
                ctx.beginPath();
                
                for (let i = 0; i < xData.length; i++) {
                    const px = x + (xData[i] - xMin) / (xMax - xMin) * width;
                    const py = y + height - (yData[i] - yMin) / (yMax - yMin) * height;
                    
                    if (i === 0) {
                        ctx.moveTo(px, py);
                    } else {
                        ctx.lineTo(px, py);
                    }
                }
                ctx.stroke();
            }

            // ÁªòÂà∂ÁªÑÂêàÂ∏ß
            drawCompositeFrame(sim, frameIndex) {
                const ctx = this.exportCtx;
                const width = this.exportCanvas.width;
                const height = this.exportCanvas.height;
                
                // Ê∏ÖÈô§ÁîªÂ∏É
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, width, height);
                
                // Ê†áÈ¢òÂå∫Âüü
                ctx.fillStyle = '#333';
                ctx.font = 'bold 36px Arial';
                ctx.textAlign = 'center';
                let title = '';
                if (this.simulatorType === 'simple') {
                    title = 'ÁÆÄË∞êÊåØÂä® Simple Harmonic Motion';
                } else if (this.simulatorType === 'damped') {
                    title = 'ÈòªÂ∞ºÊåØÂä® Damped Oscillation';
                } else {
                    title = 'ÂèóËø´ÊåØÂä® Forced Oscillation';
                }
                ctx.fillText(title, width / 2, 50);
                
                // Êó∂Èó¥‰ø°ÊÅØ
                const currentTime = sim.data.time[frameIndex] || 0;
                ctx.font = '24px Arial';
                ctx.fillText(`t = ${currentTime.toFixed(2)} s`, width / 2, 90);
                
                // ‰∏ªÂä®ÁîªÂå∫ÂüüÔºàÂ∑¶‰∏äÔºâ
                const animWidth = 640;
                const animHeight = 480;
                const animX = 50;
                const animY = 120;
                
                // ÁªòÂà∂‰∏ªÂä®ÁîªËæπÊ°Ü
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 2;
                ctx.strokeRect(animX, animY, animWidth, animHeight);
                
                // ÁªòÂà∂‰∏ªÂä®Áîª
                this.drawMainAnimationFrame(sim, frameIndex, animX, animY, animWidth, animHeight);
                
                // ÂõæË°®Âå∫ÂüüÔºàÂè≥‰æßÂíå‰∏ãÊñπÔºâ
                const chartWidth = 560;
                const chartHeight = 230;
                const chartStartX = animX + animWidth + 50;
                const chartStartY = animY;
                const chartGap = 20;
                
                // ‰ΩçÁßªÂõæË°®
                ctx.strokeRect(chartStartX, chartStartY, chartWidth, chartHeight);
                this.drawChartFrame(sim, 'displacement', frameIndex, chartStartX, chartStartY, chartWidth, chartHeight);
                
                // ÈÄüÂ∫¶ÂõæË°®
                const chart2Y = chartStartY + chartHeight + chartGap;
                ctx.strokeRect(chartStartX, chart2Y, chartWidth, chartHeight);
                this.drawChartFrame(sim, 'velocity', frameIndex, chartStartX, chart2Y, chartWidth, chartHeight);
                
                // ËÉΩÈáèÂõæË°®
                const chart3X = animX;
                const chart3Y = animY + animHeight + chartGap;
                const chart3Width = 640;
                ctx.strokeRect(chart3X, chart3Y, chart3Width, chartHeight);
                this.drawChartFrame(sim, 'energy', frameIndex, chart3X, chart3Y, chart3Width, chartHeight);
                
                // ÁâπÊÆäÂõæË°®ÔºàÁõ∏‰ΩçÂõæÊàñÂÖ±ÊåØÊõ≤Á∫øÔºâ
                if (this.simulatorType === 'simple') {
                    const chart4X = chart3X + chart3Width + 50;
                    ctx.strokeRect(chart4X, chart3Y, chartWidth, chartHeight);
                    this.drawChartFrame(sim, 'phase', frameIndex, chart4X, chart3Y, chartWidth, chartHeight);
                } else if (this.simulatorType === 'forced') {
                    const chart4X = chart3X + chart3Width + 50;
                    ctx.strokeRect(chart4X, chart3Y, chartWidth, chartHeight);
                    this.drawChartFrame(sim, 'resonance', frameIndex, chart4X, chart3Y, chartWidth, chartHeight);
                }
                
                // ÂèÇÊï∞‰ø°ÊÅØÔºàÂ∫ïÈÉ®Ôºâ
                this.drawParameterInfo(sim, frameIndex, 50, height - 100, width - 100, 80);
            }

            // ÁªòÂà∂‰∏ªÂä®ÁîªÂ∏ß
            drawMainAnimationFrame(sim, frameIndex, x, y, width, height) {
                const ctx = this.exportCtx;
                
                ctx.save();
                ctx.translate(x, y);
                
                // ËÉåÊôØ
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, width, height);
                
                const centerX = width / 2;
                const centerY = height / 2;
                const scale = Math.min(width, height) / 12;
                
                const currentPosition = sim.data.position[frameIndex] || 0;
                const currentVelocity = sim.data.velocity[frameIndex] || 0;
                
                // ÊîØÊíëÁÇπ
                ctx.fillStyle = '#333';
                ctx.fillRect(centerX - 40, 20, 80, 10);
                
                // ÂºπÁ∞ß
                ctx.strokeStyle = '#4a90e2';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                const springTop = 30;
                const springBottom = centerY + currentPosition * scale;
                const coils = 12;
                const coilHeight = (springBottom - springTop) / coils;
                
                ctx.moveTo(centerX, springTop);
                for (let i = 0; i < coils; i++) {
                    const yPos = springTop + i * coilHeight;
                    const nextY = springTop + (i + 1) * coilHeight;
                    const midY = (yPos + nextY) / 2;
                    
                    if (i % 2 === 0) {
                        ctx.quadraticCurveTo(centerX + 20, midY, centerX, nextY);
                    } else {
                        ctx.quadraticCurveTo(centerX - 20, midY, centerX, nextY);
                    }
                }
                ctx.stroke();
                
                // Ë¥®ÈáèÂùó
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(centerX - 30, springBottom - 30, 60, 60);
                
                // ÂèÇËÄÉÁ∫ø
                ctx.strokeStyle = '#95a5a6';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(0, centerY);
                ctx.lineTo(width, centerY);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Â¶ÇÊûúÊòØÂèóËø´ÊåØÂä®ÔºåÁªòÂà∂Â§ñÂäõ
                if (this.simulatorType === 'forced' && sim.data.force) {
                    const currentForce = sim.data.force[frameIndex] || 0;
                    const forceScale = 15;
                    const forceLength = currentForce * forceScale;
                    const forceX = centerX;
                    const forceBaseY = springBottom;
                    
                    ctx.strokeStyle = '#27ae60';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(forceX, forceBaseY);
                    ctx.lineTo(forceX, forceBaseY + forceLength);
                    ctx.stroke();
                    
                    if (Math.abs(forceLength) > 5) {
                        ctx.beginPath();
                        const arrowDir = forceLength > 0 ? 1 : -1;
                        ctx.moveTo(forceX, forceBaseY + forceLength);
                        ctx.lineTo(forceX - 5, forceBaseY + forceLength - 10 * arrowDir);
                        ctx.lineTo(forceX + 5, forceBaseY + forceLength - 10 * arrowDir);
                        ctx.closePath();
                        ctx.fillStyle = '#27ae60';
                        ctx.fill();
                    }
                    
                    ctx.fillStyle = '#27ae60';
                    ctx.font = 'bold 14px Arial';
                    ctx.fillText('F', forceX + 15, forceBaseY + forceLength / 2);
                }
                
                // ÂΩìÂâçÂÄº
                ctx.fillStyle = '#333';
                ctx.font = '14px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`‰ΩçÁΩÆ: ${currentPosition.toFixed(3)} m`, 10, height - 40);
                ctx.fillText(`ÈÄüÂ∫¶: ${currentVelocity.toFixed(3)} m/s`, 10, height - 20);
                
                ctx.restore();
            }

            // ÁªòÂà∂ÂõæË°®Â∏ß
            drawChartFrame(sim, chartType, frameIndex, x, y, width, height) {
                const ctx = this.exportCtx;
                
                ctx.save();
                ctx.translate(x, y);
                
                // ËÉåÊôØ
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, width, height);
                
                // ÂùêÊ†áËΩ¥
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(40, height - 30);
                ctx.lineTo(width - 20, height - 30);
                ctx.moveTo(40, height - 30);
                ctx.lineTo(40, 20);
                ctx.stroke();
                
                // Ê†πÊçÆÂõæË°®Á±ªÂûãÁªòÂà∂
                ctx.font = '12px Arial';
                ctx.fillStyle = '#333';
                ctx.textAlign = 'center';
                
                if (chartType === 'displacement') {
                    ctx.fillText('Êó∂Èó¥ (s)', width / 2, height - 5);
                    ctx.save();
                    ctx.translate(15, height / 2);
                    ctx.rotate(-Math.PI / 2);
                    ctx.fillText('‰ΩçÁßª (m)', 0, 0);
                    ctx.restore();
                    
                    this.drawLineOnChart(sim.data.time, sim.data.position, '#3498db', frameIndex, 40, 20, width - 60, height - 50);
                } else if (chartType === 'velocity') {
                    ctx.fillText('Êó∂Èó¥ (s)', width / 2, height - 5);
                    ctx.save();
                    ctx.translate(15, height / 2);
                    ctx.rotate(-Math.PI / 2);
                    ctx.fillText('ÈÄüÂ∫¶ (m/s)', 0, 0);
                    ctx.restore();
                    
                    this.drawLineOnChart(sim.data.time, sim.data.velocity, '#e74c3c', frameIndex, 40, 20, width - 60, height - 50);
                } else if (chartType === 'energy') {
                    ctx.fillText('Êó∂Èó¥ (s)', width / 2, height - 5);
                    ctx.save();
                    ctx.translate(15, height / 2);
                    ctx.rotate(-Math.PI / 2);
                    ctx.fillText('ËÉΩÈáè (J)', 0, 0);
                    ctx.restore();
                    
                    this.drawLineOnChart(sim.data.time, sim.data.kineticEnergy, '#e74c3c', frameIndex, 40, 20, width - 60, height - 50);
                    this.drawLineOnChart(sim.data.time, sim.data.potentialEnergy, '#3498db', frameIndex, 40, 20, width - 60, height - 50);
                    this.drawLineOnChart(sim.data.time, sim.data.totalEnergy, '#2c3e50', frameIndex, 40, 20, width - 60, height - 50);
                    
                    // Âõæ‰æã
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillStyle = '#e74c3c';
                    ctx.fillRect(width - 80, 25, 10, 10);
                    ctx.fillStyle = '#333';
                    ctx.fillText('Âä®ËÉΩ', width - 65, 33);
                    
                    ctx.fillStyle = '#3498db';
                    ctx.fillRect(width - 80, 40, 10, 10);
                    ctx.fillStyle = '#333';
                    ctx.fillText('ÂäøËÉΩ', width - 65, 48);
                    
                    ctx.fillStyle = '#2c3e50';
                    ctx.fillRect(width - 80, 55, 10, 10);
                    ctx.fillStyle = '#333';
                    ctx.fillText('ÊÄªËÉΩÈáè', width - 65, 63);
                } else if (chartType === 'phase') {
                    ctx.fillText('‰ΩçÁßª (m)', width - 30, height / 2 - 10);
                    ctx.save();
                    ctx.translate(width / 2 + 10, 35);
                    ctx.fillText('ÈÄüÂ∫¶ (m/s)', 0, 0);
                    ctx.restore();
                    
                    this.drawPhaseOnChart(sim.data.position, sim.data.velocity, '#667eea', frameIndex, width, height);
                } else if (chartType === 'resonance' && sim.resonanceData) {
                    ctx.fillText('È¢ëÁéáÊØî (œâ/œân)', width / 2, height - 5);
                    ctx.save();
                    ctx.translate(15, height / 2);
                    ctx.rotate(-Math.PI / 2);
                    ctx.fillText('ÊåØÂπÖ (m)', 0, 0);
                    ctx.restore();
                    
                    const omega_n = Math.sqrt(sim.params.springConstant / sim.params.mass);
                    const frequencyRatios = sim.resonanceData.frequencies.map(f => f / omega_n);
                    this.drawLineOnChart(frequencyRatios, sim.resonanceData.amplitudes, '#e74c3c', -1, 40, 20, width - 60, height - 50);
                    
                    // Ê†áËÆ∞ÂΩìÂâçÂ∑•‰ΩúÁÇπ
                    const currentRatio = sim.params.forceFrequency / omega_n;
                    const denominator = Math.sqrt(Math.pow(sim.params.springConstant - sim.params.mass * sim.params.forceFrequency * sim.params.forceFrequency, 2) + 
                                                 Math.pow(sim.params.dampingCoefficient * sim.params.forceFrequency, 2));
                    const currentAmplitude = sim.params.forceAmplitude / denominator;
                    
                    const xMin = Math.min(...frequencyRatios);
                    const xMax = Math.max(...frequencyRatios);
                    const yMin = Math.min(...sim.resonanceData.amplitudes);
                    const yMax = Math.max(...sim.resonanceData.amplitudes);
                    
                    const px = 40 + (currentRatio - xMin) / (xMax - xMin) * (width - 60);
                    const py = height - 30 - (currentAmplitude - yMin) / (yMax - yMin) * (height - 50);
                    
                    ctx.fillStyle = '#27ae60';
                    ctx.beginPath();
                    ctx.arc(px, py, 6, 0, 2 * Math.PI);
                    ctx.fill();
                }
                
                ctx.restore();
            }

            // ÁªòÂà∂Á∫øÊù°
            drawLineOnChart(xData, yData, color, currentIndex, x, y, width, height) {
                const ctx = this.exportCtx;
                
                if (xData.length === 0 || yData.length === 0) return;
                
                const xMin = Math.min(...xData);
                const xMax = Math.max(...xData);
                const yMin = Math.min(...yData);
                const yMax = Math.max(...yData);
                
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                const maxIndex = currentIndex >= 0 ? Math.min(currentIndex + 1, xData.length) : xData.length;
                
                for (let i = 0; i < maxIndex; i++) {
                    const px = x + (xData[i] - xMin) / (xMax - xMin) * width;
                    const py = y + height - (yData[i] - yMin) / (yMax - yMin) * height;
                    
                    if (i === 0) {
                        ctx.moveTo(px, py);
                    } else {
                        ctx.lineTo(px, py);
                    }
                }
                ctx.stroke();
                
                // Ê†áËÆ∞ÂΩìÂâçÁÇπ
                if (currentIndex >= 0 && currentIndex < xData.length) {
                    const px = x + (xData[currentIndex] - xMin) / (xMax - xMin) * width;
                    const py = y + height - (yData[currentIndex] - yMin) / (yMax - yMin) * height;
                    
                    ctx.fillStyle = '#e67e22';
                    ctx.beginPath();
                    ctx.arc(px, py, 5, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }

            // ÁªòÂà∂Áõ∏‰ΩçÂõæ
            drawPhaseOnChart(xData, yData, color, currentIndex, width, height) {
                const ctx = this.exportCtx;
                
                if (xData.length === 0 || yData.length === 0) return;
                
                const xMin = Math.min(...xData);
                const xMax = Math.max(...xData);
                const yMin = Math.min(...yData);
                const yMax = Math.max(...yData);
                
                // ÂùêÊ†áËΩ¥
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(width / 2, 20);
                ctx.lineTo(width / 2, height - 30);
                ctx.moveTo(40, height / 2);
                ctx.lineTo(width - 20, height / 2);
                ctx.stroke();
                
                // Áõ∏‰ΩçËΩ®Ëøπ
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                const maxIndex = currentIndex >= 0 ? Math.min(currentIndex + 1, xData.length) : xData.length;
                
                for (let i = 0; i < maxIndex; i++) {
                    const px = width / 2 + (xData[i] / Math.max(Math.abs(xMin), Math.abs(xMax))) * (width / 2 - 40);
                    const py = height / 2 - (yData[i] / Math.max(Math.abs(yMin), Math.abs(yMax))) * (height / 2 - 40);
                    
                    if (i === 0) {
                        ctx.moveTo(px, py);
                    } else {
                        ctx.lineTo(px, py);
                    }
                }
                ctx.stroke();
                
                // Ê†áËÆ∞ÂΩìÂâçÁÇπ
                if (currentIndex >= 0 && currentIndex < xData.length) {
                    const px = width / 2 + (xData[currentIndex] / Math.max(Math.abs(xMin), Math.abs(xMax))) * (width / 2 - 40);
                    const py = height / 2 - (yData[currentIndex] / Math.max(Math.abs(yMin), Math.abs(yMax))) * (height / 2 - 40);
                    
                    ctx.fillStyle = '#e74c3c';
                    ctx.beginPath();
                    ctx.arc(px, py, 5, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }

            // ÁªòÂà∂ÂèÇÊï∞‰ø°ÊÅØ
            drawParameterInfo(sim, frameIndex, x, y, width, height) {
                const ctx = this.exportCtx;
                
                ctx.save();
                ctx.translate(x, y);
                
                // ËÉåÊôØ
                ctx.fillStyle = '#f0f0f0';
                ctx.fillRect(0, 0, width, height);
                
                // ÂèÇÊï∞ÊñáÊú¨
                ctx.fillStyle = '#333';
                ctx.font = '16px Arial';
                ctx.textAlign = 'left';
                
                const params = sim.params;
                let text = `ÂèÇÊï∞: Ë¥®Èáè m = ${params.mass} kg, ÂºπÁ∞ßÂ∏∏Êï∞ k = ${params.springConstant} N/m`;
                
                if (this.simulatorType === 'damped' || this.simulatorType === 'forced') {
                    text += `, ÈòªÂ∞ºÁ≥ªÊï∞ c = ${params.dampingCoefficient} Ns/m`;
                }
                
                if (this.simulatorType === 'forced') {
                    text += `, Â§ñÂäõÂπÖÂÄº F‚ÇÄ = ${params.forceAmplitude} N, Â§ñÂäõÈ¢ëÁéá œâ = ${params.forceFrequency} rad/s`;
                }
                
                ctx.fillText(text, 10, 30);
                
                // ÂàùÂßãÊù°‰ª∂
                const initText = `ÂàùÂßãÊù°‰ª∂: x‚ÇÄ = ${params.initialPosition} m, v‚ÇÄ = ${params.initialVelocity} m/s`;
                ctx.fillText(initText, 10, 55);
                
                ctx.restore();
            }

            // ÂºÄÂßãÂΩïÂà∂
            async startRecording(sim) {
                return new Promise((resolve, reject) => {
                    try {
                        // ÂàõÂª∫ÊµÅ
                        const stream = this.exportCanvas.captureStream(30); // 30 fps
                        
                        // ÂàõÂª∫Â™í‰ΩìÂΩïÂà∂Âô®
                        this.mediaRecorder = new MediaRecorder(stream, {
                            mimeType: 'video/webm; codecs=vp9',
                            videoBitsPerSecond: 8000000 // 8 Mbps
                        });
                        
                        this.recordedChunks = [];
                        
                        this.mediaRecorder.ondataavailable = (event) => {
                            if (event.data.size > 0) {
                                this.recordedChunks.push(event.data);
                            }
                        };
                        
                        this.mediaRecorder.onstop = () => {
                            // ÂÅúÊ≠¢Êó∂ÁöÑÂ§ÑÁêÜÂú®Â§ñÈÉ®ËøõË°å
                        };
                        
                        this.mediaRecorder.start();
                        this.isRecording = true;
                        resolve();
                    } catch (error) {
                        reject(error);
                    }
                });
            }

            // ÂÅúÊ≠¢ÂΩïÂà∂
            stopRecording() {
                if (this.mediaRecorder && this.isRecording) {
                    this.mediaRecorder.stop();
                    this.isRecording = false;
                }
            }

            // ‰øùÂ≠òËßÜÈ¢ëÔºàÊîπËøõÁâàÔºåÂ∏¶ËßÜÂõæÁ±ªÂûãÔºâ
            saveVideo(sim, viewType) {
                const blob = new Blob(this.recordedChunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                
                let fileName = 'oscillation_';
                if (this.simulatorType === 'simple') {
                    fileName += 'simple_';
                } else if (this.simulatorType === 'damped') {
                    fileName += 'damped_';
                } else {
                    fileName += 'forced_';
                }
                
                // Ê∑ªÂä†ËßÜÂõæÁ±ªÂûã
                fileName += viewType + '_';
                
                const date = new Date();
                fileName += `${date.getFullYear()}${String(date.getMonth()+1).padStart(2,'0')}${String(date.getDate()).padStart(2,'0')}`;
                fileName += `_${String(date.getHours()).padStart(2,'0')}${String(date.getMinutes()).padStart(2,'0')}${String(date.getSeconds()).padStart(2,'0')}`;
                fileName += '.webm';
                
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                // Ê∏ÖÁêÜ
                URL.revokeObjectURL(url);
                this.recordedChunks = [];
            }

            // ÂØºÂá∫ÂÆåÊï¥ÁöÑÂä®ÁîªËßÜÈ¢ëÔºàÂ±ïÁ§∫ÁÇπ‰ªéÂ∑¶Âà∞Âè≥ÁöÑÁßªÂä®ËøáÁ®ãÔºâ
            async exportPeriod(sim) {
                // ËÆ°ÁÆóÈúÄË¶ÅÂΩïÂà∂ÁöÑÊÄªÊó∂ÈïøÔºàÂ±ïÁ§∫ÂÆåÊï¥ÁöÑÊï∞ÊçÆÊõ≤Á∫øÔºâ
                const displayDuration = 10; // Âú®ÂõæË°®‰∏äÊòæÁ§∫10ÁßíÁöÑÊï∞ÊçÆ
                const totalDataTime = sim.data.time[sim.data.time.length - 1]; // ÊÄªÊï∞ÊçÆÊó∂Èïø
                const recordingDuration = Math.min(totalDataTime, 20); // ÊúÄÂ§öÂΩïÂà∂20Áßí
                
                // ÂºÄÂßãÂΩïÂà∂
                await this.startRecording(sim);
                
                // ÂΩïÂà∂Â∏ß
                const fps = 30;
                const totalFrames = Math.ceil(recordingDuration * fps);
                
                for (let frameNum = 0; frameNum < totalFrames; frameNum++) {
                    const progress = frameNum / totalFrames;
                    const currentDataTime = progress * recordingDuration;
                    const dataIndex = Math.floor(currentDataTime / 0.05); // ÂÅáËÆæÊï∞ÊçÆÈááÊ†∑Èó¥Èöî‰∏∫0.05s
                    
                    if (dataIndex < sim.data.time.length) {
                        // ‰ΩøÁî®ÊªöÂä®Á™óÂè£ÊñπÂºèÁªòÂà∂
                        this.recordFrameWithScrolling(sim, dataIndex, displayDuration);
                    }
                    
                    // Á≠âÂæÖ‰∏ã‰∏ÄÂ∏ß
                    await new Promise(resolve => setTimeout(resolve, 1000 / fps));
                }
                
                // ÂÅúÊ≠¢ÂΩïÂà∂
                this.stopRecording();
            }

            // ÂΩïÂà∂Â∏¶ÊªöÂä®ÊïàÊûúÁöÑÂ∏ß
            recordFrameWithScrolling(sim, currentIndex, windowDuration) {
                if (this.isRecording) {
                    this.drawCompositeFrameWithScrolling(sim, currentIndex, windowDuration);
                }
            }

            // ÁªòÂà∂Â∏¶ÊªöÂä®ÊïàÊûúÁöÑÁªÑÂêàÂ∏ß
            drawCompositeFrameWithScrolling(sim, frameIndex, windowDuration) {
                const ctx = this.exportCtx;
                const width = this.exportCanvas.width;
                const height = this.exportCanvas.height;
                
                // Ê∏ÖÈô§ÁîªÂ∏É
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, width, height);
                
                // Ê†áÈ¢òÂå∫Âüü
                ctx.fillStyle = '#333';
                ctx.font = 'bold 36px Arial';
                ctx.textAlign = 'center';
                let title = '';
                if (this.simulatorType === 'simple') {
                    title = 'ÁÆÄË∞êÊåØÂä® Simple Harmonic Motion';
                } else if (this.simulatorType === 'damped') {
                    title = 'ÈòªÂ∞ºÊåØÂä® Damped Oscillation';
                } else {
                    title = 'ÂèóËø´ÊåØÂä® Forced Oscillation';
                }
                ctx.fillText(title, width / 2, 50);
                
                // Êó∂Èó¥‰ø°ÊÅØ
                const currentTime = sim.data.time[frameIndex] || 0;
                ctx.font = '24px Arial';
                ctx.fillText(`t = ${currentTime.toFixed(2)} s`, width / 2, 90);
                
                // ‰∏ªÂä®ÁîªÂå∫ÂüüÔºàÂ∑¶‰∏äÔºâ
                const animWidth = 640;
                const animHeight = 480;
                const animX = 50;
                const animY = 120;
                
                // ÁªòÂà∂‰∏ªÂä®ÁîªËæπÊ°Ü
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 2;
                ctx.strokeRect(animX, animY, animWidth, animHeight);
                
                // ÁªòÂà∂‰∏ªÂä®Áîª
                this.drawMainAnimationFrame(sim, frameIndex, animX, animY, animWidth, animHeight);
                
                // ÂõæË°®Âå∫ÂüüÔºàÂè≥‰æßÂíå‰∏ãÊñπÔºâ
                const chartWidth = 560;
                const chartHeight = 230;
                const chartStartX = animX + animWidth + 50;
                const chartStartY = animY;
                const chartGap = 20;
                
                // ‰ΩçÁßªÂõæË°®ÔºàÂ∏¶ÊªöÂä®Ôºâ
                ctx.strokeRect(chartStartX, chartStartY, chartWidth, chartHeight);
                this.drawScrollingChart(sim, 'displacement', frameIndex, chartStartX, chartStartY, chartWidth, chartHeight, windowDuration);
                
                // ÈÄüÂ∫¶ÂõæË°®ÔºàÂ∏¶ÊªöÂä®Ôºâ
                const chart2Y = chartStartY + chartHeight + chartGap;
                ctx.strokeRect(chartStartX, chart2Y, chartWidth, chartHeight);
                this.drawScrollingChart(sim, 'velocity', frameIndex, chartStartX, chart2Y, chartWidth, chartHeight, windowDuration);
                
                // ËÉΩÈáèÂõæË°®ÔºàÂ∏¶ÊªöÂä®Ôºâ
                const chart3X = animX;
                const chart3Y = animY + animHeight + chartGap;
                const chart3Width = 640;
                ctx.strokeRect(chart3X, chart3Y, chart3Width, chartHeight);
                this.drawScrollingChart(sim, 'energy', frameIndex, chart3X, chart3Y, chart3Width, chartHeight, windowDuration);
                
                // ÁâπÊÆäÂõæË°®ÔºàÁõ∏‰ΩçÂõæÊàñÂÖ±ÊåØÊõ≤Á∫øÔºâ
                if (this.simulatorType === 'simple') {
                    const chart4X = chart3X + chart3Width + 50;
                    ctx.strokeRect(chart4X, chart3Y, chartWidth, chartHeight);
                    this.drawChartFrame(sim, 'phase', frameIndex, chart4X, chart3Y, chartWidth, chartHeight);
                } else if (this.simulatorType === 'forced') {
                    const chart4X = chart3X + chart3Width + 50;
                    ctx.strokeRect(chart4X, chart3Y, chartWidth, chartHeight);
                    this.drawChartFrame(sim, 'resonance', frameIndex, chart4X, chart3Y, chartWidth, chartHeight);
                }
                
                // ÂèÇÊï∞‰ø°ÊÅØÔºàÂ∫ïÈÉ®Ôºâ
                this.drawParameterInfo(sim, frameIndex, 50, height - 100, width - 100, 80);
            }

            // ÁªòÂà∂ÊªöÂä®ÂõæË°®
            drawScrollingChart(sim, chartType, currentIndex, x, y, width, height, windowDuration) {
                const ctx = this.exportCtx;
                
                ctx.save();
                ctx.translate(x, y);
                
                // ËÉåÊôØ
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, width, height);
                
                // ËÆ°ÁÆóÊó∂Èó¥Á™óÂè£
                const currentTime = sim.data.time[currentIndex] || 0;
                let startTime = Math.max(0, currentTime - windowDuration * 0.8); // ÂΩìÂâçÁÇπÂú®Á™óÂè£ÁöÑ80%‰ΩçÁΩÆ
                let endTime = startTime + windowDuration;
                
                // Â¶ÇÊûúÊé•ËøëÂºÄÂßãÔºåË∞ÉÊï¥Á™óÂè£
                if (currentTime < windowDuration * 0.8) {
                    startTime = 0;
                    endTime = windowDuration;
                }
                
                // ÊâæÂà∞ÂØπÂ∫îÁöÑÊï∞ÊçÆÁ¥¢ÂºïËåÉÂõ¥
                const startIndex = Math.max(0, sim.data.time.findIndex(t => t >= startTime));
                const endIndex = Math.min(sim.data.time.length - 1, sim.data.time.findIndex(t => t > endTime));
                const actualEndIndex = endIndex === -1 ? sim.data.time.length - 1 : endIndex;
                
                // ÂùêÊ†áËΩ¥
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(40, height - 30);
                ctx.lineTo(width - 20, height - 30);
                ctx.moveTo(40, height - 30);
                ctx.lineTo(40, 20);
                ctx.stroke();
                
                // ÁªòÂà∂Êï∞ÊçÆ
                ctx.font = '12px Arial';
                ctx.fillStyle = '#333';
                ctx.textAlign = 'center';
                
                if (chartType === 'displacement') {
                    ctx.fillText('Êó∂Èó¥ (s)', width / 2, height - 5);
                    ctx.save();
                    ctx.translate(15, height / 2);
                    ctx.rotate(-Math.PI / 2);
                    ctx.fillText('‰ΩçÁßª (m)', 0, 0);
                    ctx.restore();
                    
                    // ÁªòÂà∂‰ΩçÁßªÊõ≤Á∫ø
                    this.drawScrollingLine(sim.data.time.slice(startIndex, actualEndIndex + 1), 
                                          sim.data.position.slice(startIndex, actualEndIndex + 1),
                                          '#3498db', startTime, endTime, currentIndex - startIndex,
                                          40, 20, width - 60, height - 50);
                    
                    // Â¶ÇÊûúÊòØÂèóËø´ÊåØÂä®ÔºåËøòË¶ÅÁªòÂà∂Â§ñÂäõ
                    if (this.simulatorType === 'forced') {
                        const scaledForce = sim.data.force.slice(startIndex, actualEndIndex + 1).map(f => f * 0.3);
                        this.drawScrollingLine(sim.data.time.slice(startIndex, actualEndIndex + 1),
                                              scaledForce, '#27ae60', startTime, endTime, -1,
                                              40, 20, width - 60, height - 50);
                    }
                    
                } else if (chartType === 'velocity') {
                    ctx.fillText('Êó∂Èó¥ (s)', width / 2, height - 5);
                    ctx.save();
                    ctx.translate(15, height / 2);
                    ctx.rotate(-Math.PI / 2);
                    ctx.fillText('ÈÄüÂ∫¶ (m/s)', 0, 0);
                    ctx.restore();
                    
                    this.drawScrollingLine(sim.data.time.slice(startIndex, actualEndIndex + 1),
                                          sim.data.velocity.slice(startIndex, actualEndIndex + 1),
                                          '#e74c3c', startTime, endTime, currentIndex - startIndex,
                                          40, 20, width - 60, height - 50);
                    
                } else if (chartType === 'energy') {
                    ctx.fillText('Êó∂Èó¥ (s)', width / 2, height - 5);
                    ctx.save();
                    ctx.translate(15, height / 2);
                    ctx.rotate(-Math.PI / 2);
                    ctx.fillText('ËÉΩÈáè (J)', 0, 0);
                    ctx.restore();
                    
                    // Âä®ËÉΩ
                    this.drawScrollingLine(sim.data.time.slice(startIndex, actualEndIndex + 1),
                                          sim.data.kineticEnergy.slice(startIndex, actualEndIndex + 1),
                                          '#e74c3c', startTime, endTime, -1,
                                          40, 20, width - 60, height - 50);
                    // ÂäøËÉΩ
                    this.drawScrollingLine(sim.data.time.slice(startIndex, actualEndIndex + 1),
                                          sim.data.potentialEnergy.slice(startIndex, actualEndIndex + 1),
                                          '#3498db', startTime, endTime, -1,
                                          40, 20, width - 60, height - 50);
                    // ÊÄªËÉΩÈáè
                    this.drawScrollingLine(sim.data.time.slice(startIndex, actualEndIndex + 1),
                                          sim.data.totalEnergy.slice(startIndex, actualEndIndex + 1),
                                          '#2c3e50', startTime, endTime, -1,
                                          40, 20, width - 60, height - 50);
                    
                    // Âõæ‰æã
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillStyle = '#e74c3c';
                    ctx.fillRect(width - 80, 25, 10, 10);
                    ctx.fillStyle = '#333';
                    ctx.fillText('Âä®ËÉΩ', width - 65, 33);
                    
                    ctx.fillStyle = '#3498db';
                    ctx.fillRect(width - 80, 40, 10, 10);
                    ctx.fillStyle = '#333';
                    ctx.fillText('ÂäøËÉΩ', width - 65, 48);
                    
                    ctx.fillStyle = '#2c3e50';
                    ctx.fillRect(width - 80, 55, 10, 10);
                    ctx.fillStyle = '#333';
                    ctx.fillText('ÊÄªËÉΩÈáè', width - 65, 63);
                }
                
                ctx.restore();
            }

            // ÁªòÂà∂ÊªöÂä®Á∫øÊù°
            drawScrollingLine(xData, yData, color, xMin, xMax, markerIndex, x, y, width, height) {
                const ctx = this.exportCtx;
                
                if (xData.length === 0 || yData.length === 0) return;
                
                const yMin = Math.min(...yData);
                const yMax = Math.max(...yData);
                
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let i = 0; i < xData.length; i++) {
                    const px = x + (xData[i] - xMin) / (xMax - xMin) * width;
                    const py = y + height - (yData[i] - yMin) / (yMax - yMin) * height;
                    
                    if (i === 0) {
                        ctx.moveTo(px, py);
                    } else {
                        ctx.lineTo(px, py);
                    }
                }
                ctx.stroke();
                
                // Ê†áËÆ∞ÂΩìÂâçÁÇπ
                if (markerIndex >= 0 && markerIndex < xData.length) {
                    const px = x + (xData[markerIndex] - xMin) / (xMax - xMin) * width;
                    const py = y + height - (yData[markerIndex] - yMin) / (yMax - yMin) * height;
                    
                    ctx.fillStyle = '#e67e22';
                    ctx.beginPath();
                    ctx.arc(px, py, 6, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }
        }

        // ÂàáÊç¢Ê®°ÊãüÂô®
        function switchSimulator(type) {
            // ÂÅúÊ≠¢ÂΩìÂâçÊ®°ÊãüÂô®
            if (currentSimulator === 'simple') {
                simpleSim.pauseAnimation();
            } else if (currentSimulator === 'damped') {
                dampedSim.pauseAnimation();
            } else {
                forcedSim.pauseAnimation();
            }

            // ÂàáÊç¢ÊòæÁ§∫
            document.querySelectorAll('.simulator-container').forEach(container => {
                container.classList.remove('active');
            });
            document.querySelectorAll('.selector-btn').forEach(btn => {
                btn.classList.remove('active');
            });

            if (type === 'simple') {
                document.getElementById('simpleSimulator').classList.add('active');
                document.querySelector('[onclick="switchSimulator(\'simple\')"]').classList.add('active');
                currentSimulator = 'simple';
                // ÈáçÊñ∞ËÆæÁΩÆcanvasÂ∞∫ÂØ∏
                setTimeout(() => simpleSim.handleResize(), 100);
            } else if (type === 'damped') {
                document.getElementById('dampedSimulator').classList.add('active');
                document.querySelector('[onclick="switchSimulator(\'damped\')"]').classList.add('active');
                currentSimulator = 'damped';
                // ÈáçÊñ∞ËÆæÁΩÆcanvasÂ∞∫ÂØ∏
                setTimeout(() => dampedSim.handleResize(), 100);
            } else {
                document.getElementById('forcedSimulator').classList.add('active');
                document.querySelector('[onclick="switchSimulator(\'forced\')"]').classList.add('active');
                currentSimulator = 'forced';
                // ÈáçÊñ∞ËÆæÁΩÆcanvasÂ∞∫ÂØ∏
                setTimeout(() => forcedSim.handleResize(), 100);
            }
        }

        // ============= ÁÆÄË∞êÊåØÂä®Ê®°ÊãüÂô® =============
        const simpleSim = {
            // Áä∂ÊÄÅ
            state: {
                isPlaying: false,
                currentIndex: 0,
                animationId: null,
                animationSpeed: 1.0,
                chartsVisible: false,
                initialized: false
            },

            // Áâ©ÁêÜÂèÇÊï∞
            params: {
                mass: 1,
                springConstant: 10,
                initialPosition: 2,
                initialVelocity: 0
            },

            // Êï∞ÊçÆÊï∞ÁªÑ
            data: {
                time: [],
                position: [],
                velocity: [],
                acceleration: [],
                kineticEnergy: [],
                potentialEnergy: [],
                totalEnergy: []
            },

            // CanvasÂºïÁî®
            canvases: {},
            contexts: {},

            // ËßÜÈ¢ëÂØºÂá∫Âô®
            exporter: null,

            // ÂàùÂßãÂåñ
            init() {
                this.initializeCanvases();
                this.setupEventListeners();
                this.calculatePhysics();
                this.updateSystemInfo();
                this.drawMainAnimation();
                this.exporter = new VideoExporter('simple');
                this.state.initialized = true;
            },

            // ÂàùÂßãÂåñCanvas
            initializeCanvases() {
                const animCanvas = document.getElementById('simple-animationCanvas');
                if (animCanvas) {
                    this.canvases.animation = animCanvas;
                    this.contexts.animation = animCanvas.getContext('2d');
                    this.setCanvasSize(animCanvas);
                }

                ['displacement', 'velocity', 'energy', 'phase'].forEach(id => {
                    const canvas = document.getElementById('simple-' + id + 'Canvas');
                    if (canvas) {
                        this.canvases[id] = canvas;
                        this.contexts[id] = canvas.getContext('2d');
                        this.setCanvasSize(canvas);
                    }
                });
            },

            // ËÆæÁΩÆCanvasÂ∞∫ÂØ∏
            setCanvasSize(canvas) {
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height;
            },

            // Â§ÑÁêÜÁ™óÂè£Ë∞ÉÊï¥
            handleResize() {
                Object.values(this.canvases).forEach(canvas => {
                    if (canvas) this.setCanvasSize(canvas);
                });
                this.drawMainAnimation();
                if (this.state.chartsVisible) {
                    this.drawCurrentChart();
                }
            },

            // ËÆæÁΩÆ‰∫ã‰ª∂ÁõëÂê¨Âô®
            setupEventListeners() {
                const self = this;
                
                document.getElementById('simple-startBtn').addEventListener('click', () => self.startAnimation());
                document.getElementById('simple-pauseBtn').addEventListener('click', () => self.pauseAnimation());
                document.getElementById('simple-resetBtn').addEventListener('click', () => self.resetAnimation());
                document.getElementById('simple-toggleChartsBtn').addEventListener('click', () => self.toggleCharts());
                document.getElementById('simple-exportBtn').addEventListener('click', () => self.exportVideo());

                // Ê†áÁ≠æÈ°µ
                document.querySelectorAll('#simple-chartsContent .tab-button').forEach(btn => {
                    btn.addEventListener('click', function() {
                        self.switchTab(this.dataset.tab);
                    });
                });

                // ÂèÇÊï∞ÁõëÂê¨Âô®
                this.setupParameterListeners();

                // ÈÄüÂ∫¶ÊéßÂà∂
                const speedSlider = document.getElementById('simple-speedSlider');
                speedSlider.addEventListener('input', function() {
                    self.state.animationSpeed = parseFloat(this.value);
                    document.getElementById('simple-speedDisplay').textContent = self.state.animationSpeed.toFixed(1) + 'x';
                });
            },

            // ËÆæÁΩÆÂèÇÊï∞ÁõëÂê¨Âô®
            setupParameterListeners() {
                const self = this;
                const parameters = [
                    { slider: 'simple-massSlider', input: 'simple-massInput', param: 'mass' },
                    { slider: 'simple-springSlider', input: 'simple-springInput', param: 'springConstant' },
                    { slider: 'simple-positionSlider', input: 'simple-positionInput', param: 'initialPosition' },
                    { slider: 'simple-velocitySlider', input: 'simple-velocityInput', param: 'initialVelocity' }
                ];

                parameters.forEach(({ slider, input, param }) => {
                    const sliderEl = document.getElementById(slider);
                    const inputEl = document.getElementById(input);

                    sliderEl.addEventListener('input', function() {
                        inputEl.value = this.value;
                        self.params[param] = parseFloat(this.value);
                        self.resetAnimation();
                    });

                    inputEl.addEventListener('change', function() {
                        sliderEl.value = this.value;
                        self.params[param] = parseFloat(this.value);
                        self.resetAnimation();
                    });
                });
            },

            // ËÆ°ÁÆóÁâ©ÁêÜÊï∞ÊçÆ
            calculatePhysics() {
                Object.keys(this.data).forEach(key => {
                    this.data[key] = [];
                });

                const { mass, springConstant, initialPosition, initialVelocity } = this.params;
                const omega = Math.sqrt(springConstant / mass);
                const dt = 0.05;
                const t_max = 20;

                // ËÆ°ÁÆóÊåØÂπÖÂíåÁõ∏‰Ωç
                const A = Math.sqrt(initialPosition * initialPosition + 
                                  Math.pow(initialVelocity / omega, 2));
                const phi = Math.atan2(-initialVelocity / omega, initialPosition);

                for (let t = 0; t <= t_max; t += dt) {
                    this.data.time.push(t);

                    // ÁÆÄË∞êÊåØÂä®ÊñπÁ®ã
                    const position = A * Math.cos(omega * t + phi);
                    const velocity = -A * omega * Math.sin(omega * t + phi);
                    const acceleration = -omega * omega * position;

                    this.data.position.push(position);
                    this.data.velocity.push(velocity);
                    this.data.acceleration.push(acceleration);

                    // ËÉΩÈáèËÆ°ÁÆó
                    const ke = 0.5 * mass * velocity * velocity;
                    const pe = 0.5 * springConstant * position * position;
                    const total = ke + pe;

                    this.data.kineticEnergy.push(ke);
                    this.data.potentialEnergy.push(pe);
                    this.data.totalEnergy.push(total);
                }
            },

            // Êõ¥Êñ∞Á≥ªÁªü‰ø°ÊÅØ
            updateSystemInfo() {
                const { mass, springConstant, initialPosition, initialVelocity } = this.params;
                const omega = Math.sqrt(springConstant / mass);
                const frequency = omega / (2 * Math.PI);
                const period = 2 * Math.PI / omega;
                
                // ËÆ°ÁÆóÊåØÂπÖ
                const amplitude = Math.sqrt(initialPosition * initialPosition + 
                                          Math.pow(initialVelocity / omega, 2));
                
                // ÊÄªËÉΩÈáèÔºàÂÆàÊÅíÔºâ
                const totalEnergy = 0.5 * springConstant * amplitude * amplitude;

                document.getElementById('simple-angularFrequency').textContent = omega.toFixed(3) + ' rad/s';
                document.getElementById('simple-frequency').textContent = frequency.toFixed(3) + ' Hz';
                document.getElementById('simple-period').textContent = period.toFixed(3) + ' s';
                document.getElementById('simple-amplitude').textContent = amplitude.toFixed(3) + ' m';
                document.getElementById('simple-totalEnergy').textContent = totalEnergy.toFixed(3) + ' J';
            },

            // ÁªòÂà∂‰∏ªÂä®Áîª
            drawMainAnimation() {
                const canvas = this.canvases.animation;
                const ctx = this.contexts.animation;
                
                if (!canvas || !ctx) return;

                const width = canvas.width;
                const height = canvas.height;
                
                ctx.clearRect(0, 0, width, height);

                if (this.data.position.length === 0) return;
                
                const index = Math.min(Math.floor(this.state.currentIndex), this.data.position.length - 1);
                const currentPosition = this.data.position[index];
                const currentVelocity = this.data.velocity[index];
                const currentTime = this.data.time[index];

                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, width, height);

                const centerX = width / 2;
                const centerY = height / 2;
                const scale = Math.min(width, height) / 12;

                // ÊîØÊíëÁÇπ
                ctx.fillStyle = '#333';
                ctx.fillRect(centerX - 40, 20, 80, 10);

                // ÂºπÁ∞ß
                ctx.strokeStyle = '#4a90e2';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                const springTop = 30;
                const springBottom = centerY + currentPosition * scale;
                const coils = 12;
                const coilHeight = (springBottom - springTop) / coils;
                
                ctx.moveTo(centerX, springTop);
                for (let i = 0; i < coils; i++) {
                    const y = springTop + i * coilHeight;
                    const nextY = springTop + (i + 1) * coilHeight;
                    const midY = (y + nextY) / 2;
                    
                    if (i % 2 === 0) {
                        ctx.quadraticCurveTo(centerX + 20, midY, centerX, nextY);
                    } else {
                        ctx.quadraticCurveTo(centerX - 20, midY, centerX, nextY);
                    }
                }
                ctx.stroke();

                // Ë¥®ÈáèÂùó
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(centerX - 30, springBottom - 30, 60, 60);
                
                // ÂèÇËÄÉÁ∫ø
                ctx.strokeStyle = '#95a5a6';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(0, centerY);
                ctx.lineTo(width, centerY);
                ctx.stroke();
                ctx.setLineDash([]);

                // ÂΩìÂâçÂÄº
                ctx.fillStyle = '#333';
                ctx.font = '14px Arial';
                ctx.fillText(`‰ΩçÁΩÆ: ${currentPosition.toFixed(3)} m`, 10, height - 40);
                ctx.fillText(`ÈÄüÂ∫¶: ${currentVelocity.toFixed(3)} m/s`, 10, height - 20);

                document.getElementById('simple-currentTime').textContent = currentTime.toFixed(2) + ' s';
            },

            // ÁªòÂà∂ÂõæË°®
            drawDisplacementChart() {
                const ctx = this.contexts.displacement;
                if (!ctx) return;
                this.drawLineChart(ctx, this.data.time, this.data.position, 'Êó∂Èó¥ (s)', '‰ΩçÁßª (m)', '#3498db', true, '#e67e22');
            },

            drawVelocityChart() {
                const ctx = this.contexts.velocity;
                if (!ctx) return;
                this.drawLineChart(ctx, this.data.time, this.data.velocity, 'Êó∂Èó¥ (s)', 'ÈÄüÂ∫¶ (m/s)', '#e74c3c', true, '#3498db');
            },

            drawEnergyChart() {
                const ctx = this.contexts.energy;
                if (!ctx) return;
                
                const canvas = ctx.canvas;
                const width = canvas.width;
                const height = canvas.height;
                
                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, width, height);
                
                this.drawLine(ctx, this.data.time, this.data.kineticEnergy, '#e74c3c', width, height);
                this.drawLine(ctx, this.data.time, this.data.potentialEnergy, '#3498db', width, height);
                this.drawLine(ctx, this.data.time, this.data.totalEnergy, '#2c3e50', width, height);
                
                // Âõæ‰æã
                ctx.font = '12px Arial';
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(width - 100, 20, 15, 15);
                ctx.fillStyle = '#333';
                ctx.fillText('Âä®ËÉΩ', width - 80, 32);
                
                ctx.fillStyle = '#3498db';
                ctx.fillRect(width - 100, 40, 15, 15);
                ctx.fillStyle = '#333';
                ctx.fillText('ÂäøËÉΩ', width - 80, 52);
                
                ctx.fillStyle = '#2c3e50';
                ctx.fillRect(width - 100, 60, 15, 15);
                ctx.fillStyle = '#333';
                ctx.fillText('ÊÄªËÉΩÈáè', width - 80, 72);
            },

            drawPhaseChart() {
                const ctx = this.contexts.phase;
                if (!ctx) return;
                
                const canvas = ctx.canvas;
                const width = canvas.width;
                const height = canvas.height;
                
                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, width, height);
                
                // ÂùêÊ†áËΩ¥
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(width / 2, 20);
                ctx.lineTo(width / 2, height - 30);
                ctx.moveTo(40, height / 2);
                ctx.lineTo(width - 20, height / 2);
                ctx.stroke();
                
                // Ê†áÁ≠æ
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.fillText('‰ΩçÁßª (m)', width - 60, height / 2 - 10);
                ctx.fillText('ÈÄüÂ∫¶ (m/s)', width / 2 + 10, 35);
                
                // ÁªòÂà∂Áõ∏‰ΩçËΩ®Ëøπ
                const xMin = Math.min(...this.data.position);
                const xMax = Math.max(...this.data.position);
                const vMin = Math.min(...this.data.velocity);
                const vMax = Math.max(...this.data.velocity);
                
                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let i = 0; i < this.data.position.length; i++) {
                    const x = width / 2 + (this.data.position[i] / Math.max(Math.abs(xMin), Math.abs(xMax))) * (width / 2 - 40);
                    const y = height / 2 - (this.data.velocity[i] / Math.max(Math.abs(vMin), Math.abs(vMax))) * (height / 2 - 40);
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
                
                // Ê†áËÆ∞ÂΩìÂâçÁÇπ
                if (this.state.currentIndex < this.data.position.length) {
                    const index = Math.floor(this.state.currentIndex);
                    const x = width / 2 + (this.data.position[index] / Math.max(Math.abs(xMin), Math.abs(xMax))) * (width / 2 - 40);
                    const y = height / 2 - (this.data.velocity[index] / Math.max(Math.abs(vMin), Math.abs(vMax))) * (height / 2 - 40);
                    
                    ctx.fillStyle = '#e74c3c';
                    ctx.beginPath();
                    ctx.arc(x, y, 5, 0, 2 * Math.PI);
                    ctx.fill();
                }
            },

            // ÈÄöÁî®ÁªòÂõæÂáΩÊï∞
            drawLineChart(ctx, xData, yData, xLabel, yLabel, color, showMarker = true, markerColor = '#e67e22') {
                const canvas = ctx.canvas;
                const width = canvas.width;
                const height = canvas.height;
                
                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, width, height);
                
                if (xData.length === 0 || yData.length === 0) return;
                
                // ÂùêÊ†áËΩ¥
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(40, height - 30);
                ctx.lineTo(width - 20, height - 30);
                ctx.moveTo(40, height - 30);
                ctx.lineTo(40, 20);
                ctx.stroke();
                
                // Ê†áÁ≠æ
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.fillText(xLabel, width / 2 - 20, height - 5);
                
                ctx.save();
                ctx.translate(15, height / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText(yLabel, 0, 0);
                ctx.restore();
                
                this.drawLine(ctx, xData, yData, color, width, height);
                
                // Ê†áËÆ∞ÂΩìÂâçÁÇπ
                if (showMarker && this.state.currentIndex < xData.length) {
                    const index = Math.floor(this.state.currentIndex);
                    const xMin = Math.min(...xData);
                    const xMax = Math.max(...xData);
                    const yMin = Math.min(...yData);
                    const yMax = Math.max(...yData);
                    
                    const x = 40 + (xData[index] - xMin) / (xMax - xMin) * (width - 60);
                    const y = height - 30 - (yData[index] - yMin) / (yMax - yMin) * (height - 50);
                    
                    ctx.fillStyle = markerColor;
                    ctx.beginPath();
                    ctx.arc(x, y, 5, 0, 2 * Math.PI);
                    ctx.fill();
                }
            },

            drawLine(ctx, xData, yData, color, width, height) {
                if (xData.length === 0 || yData.length === 0) return;
                
                const xMin = Math.min(...xData);
                const xMax = Math.max(...xData);
                const yMin = Math.min(...yData);
                const yMax = Math.max(...yData);
                
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let i = 0; i < xData.length; i++) {
                    const x = 40 + (xData[i] - xMin) / (xMax - xMin) * (width - 60);
                    const y = height - 30 - (yData[i] - yMin) / (yMax - yMin) * (height - 50);
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
            },

            // Âä®ÁîªÊéßÂà∂
            animate() {
                if (!this.state.isPlaying) return;
                
                this.state.currentIndex += this.state.animationSpeed;
                
                if (this.state.currentIndex >= this.data.time.length) {
                    this.state.currentIndex = 0;
                }
                
                this.drawMainAnimation();
                
                if (this.state.chartsVisible) {
                    this.drawCurrentChart();
                }
                
                this.state.animationId = requestAnimationFrame(() => this.animate());
            },

            startAnimation() {
                if (!this.state.isPlaying && this.state.initialized) {
                    this.state.isPlaying = true;
                    document.getElementById('simple-startBtn').disabled = true;
                    document.getElementById('simple-pauseBtn').disabled = false;
                    this.animate();
                }
            },

            pauseAnimation() {
                this.state.isPlaying = false;
                if (this.state.animationId) {
                    cancelAnimationFrame(this.state.animationId);
                }
                document.getElementById('simple-startBtn').disabled = false;
                document.getElementById('simple-pauseBtn').disabled = true;
            },

            resetAnimation() {
                this.pauseAnimation();
                this.state.currentIndex = 0;
                this.calculatePhysics();
                this.updateSystemInfo();
                this.drawMainAnimation();
                if (this.state.chartsVisible) {
                    this.drawCurrentChart();
                }
            },

            toggleCharts() {
                this.state.chartsVisible = !this.state.chartsVisible;
                const chartsContent = document.getElementById('simple-chartsContent');
                const toggleBtn = document.getElementById('simple-toggleChartsBtn');
                
                if (this.state.chartsVisible) {
                    chartsContent.classList.add('active');
                    toggleBtn.textContent = 'ÈöêËóèÂõæË°®';
                    
                    setTimeout(() => {
                        ['displacement', 'velocity', 'energy', 'phase'].forEach(id => {
                            const canvas = document.getElementById('simple-' + id + 'Canvas');
                            if (canvas) {
                                this.setCanvasSize(canvas);
                                if (!this.contexts[id]) {
                                    this.contexts[id] = canvas.getContext('2d');
                                }
                            }
                        });
                        
                        this.drawDisplacementChart();
                        this.drawVelocityChart();
                        this.drawEnergyChart();
                        this.drawPhaseChart();
                    }, 50);
                } else {
                    chartsContent.classList.remove('active');
                    toggleBtn.textContent = 'ÊòæÁ§∫ÂõæË°®';
                }
            },

            switchTab(tabName) {
                document.querySelectorAll('#simple-chartsContent .tab-button').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.tab === tabName) {
                        btn.classList.add('active');
                    }
                });
                
                document.querySelectorAll('#simple-chartsContent .chart-canvas').forEach(canvas => {
                    canvas.classList.remove('active');
                });
                
                const targetCanvas = document.getElementById('simple-' + tabName + 'Canvas');
                if (targetCanvas) {
                    targetCanvas.classList.add('active');
                    
                    switch(tabName) {
                        case 'displacement':
                            this.drawDisplacementChart();
                            break;
                        case 'velocity':
                            this.drawVelocityChart();
                            break;
                        case 'energy':
                            this.drawEnergyChart();
                            break;
                        case 'phase':
                            this.drawPhaseChart();
                            break;
                    }
                }
            },

            drawCurrentChart() {
                if (!this.state.chartsVisible) return;
                
                const activeCanvas = document.querySelector('#simple-chartsContent .chart-canvas.active');
                if (!activeCanvas) return;
                
                const canvasId = activeCanvas.id;
                
                if (canvasId.includes('displacement')) {
                    this.drawDisplacementChart();
                } else if (canvasId.includes('velocity')) {
                    this.drawVelocityChart();
                } else if (canvasId.includes('energy')) {
                    this.drawEnergyChart();
                } else if (canvasId.includes('phase')) {
                    this.drawPhaseChart();
                }
            },

            // ÂØºÂá∫ËßÜÈ¢ëÔºàÊòæÁ§∫ÈÄâÈ°πËèúÂçïÔºâ
            async exportVideo() {
                const statusEl = document.getElementById('simple-exportStatus');
                const exportBtn = document.getElementById('simple-exportBtn');
                
                // Ê£ÄÊµãÊòØÂê¶‰∏∫ÁßªÂä®ËÆæÂ§á
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                
                // ÂàõÂª∫ÂØºÂá∫ÈÄâÈ°πËèúÂçïÔºàÁßªÂä®Á´Ø‰ºòÂåñÔºâ
                const options = `
                    <div style="margin-bottom: 10px; font-weight: bold; font-size: ${isMobile ? '14px' : '16px'};">ÈÄâÊã©Ë¶ÅÂØºÂá∫ÁöÑËßÜÈ¢ëÔºö</div>
                    <div style="display: flex; flex-wrap: wrap; gap: 5px;">
                        <button onclick="simpleSim.exportSpecificVideo('animation')" 
                            style="flex: ${isMobile ? '1 1 45%' : '1'}; 
                                   margin: 2px; 
                                   padding: ${isMobile ? '12px 8px' : '8px'}; 
                                   font-size: ${isMobile ? '13px' : '14px'}; 
                                   border: 1px solid #ddd; 
                                   border-radius: 5px; 
                                   background: white; 
                                   cursor: pointer;">‰∏ªÂä®Áîª</button>
                        <button onclick="simpleSim.exportSpecificVideo('displacement')" 
                            style="flex: ${isMobile ? '1 1 45%' : '1'}; 
                                   margin: 2px; 
                                   padding: ${isMobile ? '12px 8px' : '8px'}; 
                                   font-size: ${isMobile ? '13px' : '14px'}; 
                                   border: 1px solid #ddd; 
                                   border-radius: 5px; 
                                   background: white; 
                                   cursor: pointer;">‰ΩçÁßªÂõæ</button>
                        <button onclick="simpleSim.exportSpecificVideo('velocity')" 
                            style="flex: ${isMobile ? '1 1 45%' : '1'}; 
                                   margin: 2px; 
                                   padding: ${isMobile ? '12px 8px' : '8px'}; 
                                   font-size: ${isMobile ? '13px' : '14px'}; 
                                   border: 1px solid #ddd; 
                                   border-radius: 5px; 
                                   background: white; 
                                   cursor: pointer;">ÈÄüÂ∫¶Âõæ</button>
                        <button onclick="simpleSim.exportSpecificVideo('energy')" 
                            style="flex: ${isMobile ? '1 1 45%' : '1'}; 
                                   margin: 2px; 
                                   padding: ${isMobile ? '12px 8px' : '8px'}; 
                                   font-size: ${isMobile ? '13px' : '14px'}; 
                                   border: 1px solid #ddd; 
                                   border-radius: 5px; 
                                   background: white; 
                                   cursor: pointer;">ËÉΩÈáèÂõæ</button>
                        <button onclick="simpleSim.exportSpecificVideo('phase')" 
                            style="flex: ${isMobile ? '1 1 45%' : '1'}; 
                                   margin: 2px; 
                                   padding: ${isMobile ? '12px 8px' : '8px'}; 
                                   font-size: ${isMobile ? '13px' : '14px'}; 
                                   border: 1px solid #ddd; 
                                   border-radius: 5px; 
                                   background: white; 
                                   cursor: pointer;">Áõ∏‰ΩçÂõæ</button>
                        <button onclick="simpleSim.exportSpecificVideo('all')" 
                            style="flex: ${isMobile ? '1 1 45%' : '1'}; 
                                   margin: 2px; 
                                   padding: ${isMobile ? '12px 8px' : '8px'}; 
                                   font-size: ${isMobile ? '13px' : '14px'}; 
                                   background: #27ae60; 
                                   color: white; 
                                   border: none; 
                                   border-radius: 5px; 
                                   cursor: pointer;">ÂØºÂá∫ÂÖ®ÈÉ®</button>
                        <button onclick="simpleSim.cancelExport()" 
                            style="flex: ${isMobile ? '1 1 100%' : '1'}; 
                                   margin: 2px; 
                                   padding: ${isMobile ? '12px 8px' : '8px'}; 
                                   font-size: ${isMobile ? '13px' : '14px'}; 
                                   background: #e74c3c; 
                                   color: white; 
                                   border: none; 
                                   border-radius: 5px; 
                                   cursor: pointer;">ÂèñÊ∂à</button>
                    </div>
                `;
                
                statusEl.innerHTML = options;
                statusEl.className = 'export-status active';
            },
            
            // ÂèñÊ∂àÂØºÂá∫
            cancelExport() {
                const statusEl = document.getElementById('simple-exportStatus');
                statusEl.classList.remove('active');
            },
            
            // ÂØºÂá∫ÁâπÂÆöËßÜÈ¢ë
            async exportSpecificVideo(videoType) {
                const statusEl = document.getElementById('simple-exportStatus');
                const exportBtn = document.getElementById('simple-exportBtn');
                
                try {
                    // ÊöÇÂÅúÂä®Áîª
                    const wasPlaying = this.state.isPlaying;
                    this.pauseAnimation();
                    
                    // Á°Æ‰øùÊâÄÊúâÂõæË°®ÈÉΩÊòæÁ§∫ÔºàÂ¶ÇÊûúÈúÄË¶ÅÔºâ
                    if (videoType !== 'animation' && !this.state.chartsVisible) {
                        this.toggleCharts();
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                    
                    if (videoType === 'all') {
                        // ÂØºÂá∫ÊâÄÊúâËßÜÈ¢ë
                        statusEl.className = 'export-status active recording';
                        statusEl.textContent = 'üî¥ Ê≠£Âú®ÂØºÂá∫ÊâÄÊúâËßÜÈ¢ë...';
                        exportBtn.disabled = true;
                        
                        await this.exporter.exportAllVideos(this);
                        
                        statusEl.className = 'export-status active success';
                        statusEl.textContent = '‚úÖ ÊâÄÊúâËßÜÈ¢ëÂØºÂá∫ÊàêÂäüÔºÅ';
                    } else {
                        // ÂØºÂá∫Âçï‰∏™ËßÜÈ¢ë
                        statusEl.className = 'export-status active recording';
                        statusEl.textContent = `üî¥ Ê≠£Âú®ÂØºÂá∫${this.getVideoTypeName(videoType)}...`;
                        exportBtn.disabled = true;
                        
                        await this.exporter.exportSingleVideo(this, videoType);
                        
                        statusEl.className = 'export-status active success';
                        statusEl.textContent = `‚úÖ ${this.getVideoTypeName(videoType)}ÂØºÂá∫ÊàêÂäüÔºÅ`;
                    }
                    
                    // ÊÅ¢Â§çÂä®ÁîªÁä∂ÊÄÅ
                    if (wasPlaying) {
                        this.startAnimation();
                    }
                    
                } catch (error) {
                    console.error('ÂØºÂá∫Â§±Ë¥•:', error);
                    statusEl.className = 'export-status active error';
                    statusEl.textContent = '‚ùå ÂØºÂá∫Â§±Ë¥•: ' + error.message;
                } finally {
                    exportBtn.disabled = false;
                    
                    // 3ÁßíÂêéÈöêËóèÁä∂ÊÄÅ
                    setTimeout(() => {
                        statusEl.classList.remove('active');
                    }, 3000);
                }
            },
            
            // Ëé∑ÂèñËßÜÈ¢ëÁ±ªÂûãÂêçÁß∞
            getVideoTypeName(videoType) {
                const names = {
                    'animation': '‰∏ªÂä®ÁîªËßÜÈ¢ë',
                    'displacement': '‰ΩçÁßªÂõæËßÜÈ¢ë',
                    'velocity': 'ÈÄüÂ∫¶ÂõæËßÜÈ¢ë',
                    'energy': 'ËÉΩÈáèÂõæËßÜÈ¢ë',
                    'phase': 'Áõ∏‰ΩçÂõæËßÜÈ¢ë'
                };
                return names[videoType] || videoType;
            }
        };

        // ============= ÈòªÂ∞ºÊåØÂä®Ê®°ÊãüÂô® =============
        const dampedSim = {
            // Áä∂ÊÄÅ
            state: {
                isPlaying: false,
                currentIndex: 0,
                animationId: null,
                animationSpeed: 1.0,
                chartsVisible: false,
                initialized: false
            },

            // Áâ©ÁêÜÂèÇÊï∞
            params: {
                mass: 1,
                springConstant: 10,
                dampingCoefficient: 0.5,
                initialPosition: 2,
                initialVelocity: 0
            },

            // Êï∞ÊçÆÊï∞ÁªÑ
            data: {
                time: [],
                position: [],
                velocity: [],
                kineticEnergy: [],
                potentialEnergy: [],
                totalEnergy: []
            },

            // CanvasÂºïÁî®
            canvases: {},
            contexts: {},

            // ËßÜÈ¢ëÂØºÂá∫Âô®
            exporter: null,

            // ÂàùÂßãÂåñ
            init() {
                this.initializeCanvases();
                this.setupEventListeners();
                this.calculatePhysics();
                this.updateSystemInfo();
                this.drawMainAnimation();
                this.exporter = new VideoExporter('damped');
                this.state.initialized = true;
            },

            // ÂàùÂßãÂåñCanvas
            initializeCanvases() {
                const animCanvas = document.getElementById('damped-animationCanvas');
                if (animCanvas) {
                    this.canvases.animation = animCanvas;
                    this.contexts.animation = animCanvas.getContext('2d');
                    this.setCanvasSize(animCanvas);
                }

                ['displacement', 'velocity', 'energy'].forEach(id => {
                    const canvas = document.getElementById('damped-' + id + 'Canvas');
                    if (canvas) {
                        this.canvases[id] = canvas;
                        this.contexts[id] = canvas.getContext('2d');
                        this.setCanvasSize(canvas);
                    }
                });
            },

            // ËÆæÁΩÆCanvasÂ∞∫ÂØ∏
            setCanvasSize(canvas) {
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height;
            },

            // Â§ÑÁêÜÁ™óÂè£Ë∞ÉÊï¥
            handleResize() {
                Object.values(this.canvases).forEach(canvas => {
                    if (canvas) this.setCanvasSize(canvas);
                });
                this.drawMainAnimation();
                if (this.state.chartsVisible) {
                    this.drawCurrentChart();
                }
            },

            // ËÆæÁΩÆ‰∫ã‰ª∂ÁõëÂê¨Âô®
            setupEventListeners() {
                const self = this;
                
                document.getElementById('damped-startBtn').addEventListener('click', () => self.startAnimation());
                document.getElementById('damped-pauseBtn').addEventListener('click', () => self.pauseAnimation());
                document.getElementById('damped-resetBtn').addEventListener('click', () => self.resetAnimation());
                document.getElementById('damped-toggleChartsBtn').addEventListener('click', () => self.toggleCharts());
                document.getElementById('damped-exportBtn').addEventListener('click', () => self.exportVideo());

                // Ê†áÁ≠æÈ°µ
                document.querySelectorAll('#damped-chartsContent .tab-button').forEach(btn => {
                    btn.addEventListener('click', function() {
                        self.switchTab(this.dataset.tab);
                    });
                });

                // ÂèÇÊï∞ÁõëÂê¨Âô®
                this.setupParameterListeners();

                // ÈÄüÂ∫¶ÊéßÂà∂
                const speedSlider = document.getElementById('damped-speedSlider');
                speedSlider.addEventListener('input', function() {
                    self.state.animationSpeed = parseFloat(this.value);
                    document.getElementById('damped-speedDisplay').textContent = self.state.animationSpeed.toFixed(1) + 'x';
                });
            },

            // ËÆæÁΩÆÂèÇÊï∞ÁõëÂê¨Âô®
            setupParameterListeners() {
                const self = this;
                const parameters = [
                    { slider: 'damped-massSlider', input: 'damped-massInput', param: 'mass' },
                    { slider: 'damped-springSlider', input: 'damped-springInput', param: 'springConstant' },
                    { slider: 'damped-dampingSlider', input: 'damped-dampingInput', param: 'dampingCoefficient' },
                    { slider: 'damped-positionSlider', input: 'damped-positionInput', param: 'initialPosition' },
                    { slider: 'damped-velocitySlider', input: 'damped-velocityInput', param: 'initialVelocity' }
                ];

                parameters.forEach(({ slider, input, param }) => {
                    const sliderEl = document.getElementById(slider);
                    const inputEl = document.getElementById(input);

                    sliderEl.addEventListener('input', function() {
                        inputEl.value = this.value;
                        self.params[param] = parseFloat(this.value);
                        self.resetAnimation();
                    });

                    inputEl.addEventListener('change', function() {
                        sliderEl.value = this.value;
                        self.params[param] = parseFloat(this.value);
                        self.resetAnimation();
                    });
                });
            },

            // ËÆ°ÁÆóÁâ©ÁêÜÊï∞ÊçÆ
            calculatePhysics() {
                Object.keys(this.data).forEach(key => {
                    this.data[key] = [];
                });

                const { mass, springConstant, dampingCoefficient, initialPosition, initialVelocity } = this.params;
                const omega_n = Math.sqrt(springConstant / mass);
                const zeta = dampingCoefficient / (2 * Math.sqrt(mass * springConstant));
                const dt = 0.05;
                const t_max = 20;

                for (let t = 0; t <= t_max; t += dt) {
                    this.data.time.push(t);

                    let position, velocity;

                    if (zeta < 1) {
                        const omega_d = omega_n * Math.sqrt(1 - zeta * zeta);
                        const A = Math.sqrt(
                            initialPosition * initialPosition + 
                            Math.pow((initialVelocity + zeta * omega_n * initialPosition) / omega_d, 2)
                        );
                        const phi = Math.atan2(
                            initialVelocity + zeta * omega_n * initialPosition,
                            initialPosition * omega_d
                        );

                        position = A * Math.exp(-zeta * omega_n * t) * Math.cos(omega_d * t - phi);
                        velocity = -A * Math.exp(-zeta * omega_n * t) * 
                                  (zeta * omega_n * Math.cos(omega_d * t - phi) + 
                                   omega_d * Math.sin(omega_d * t - phi));
                    } else if (Math.abs(zeta - 1) < 0.01) {
                        const C1 = initialPosition;
                        const C2 = initialVelocity + omega_n * initialPosition;
                        position = (C1 + C2 * t) * Math.exp(-omega_n * t);
                        velocity = (C2 - omega_n * (C1 + C2 * t)) * Math.exp(-omega_n * t);
                    } else {
                        const sqrt_term = Math.sqrt(zeta * zeta - 1);
                        const r1 = -omega_n * (zeta - sqrt_term);
                        const r2 = -omega_n * (zeta + sqrt_term);
                        const C1 = (initialVelocity - r2 * initialPosition) / (r1 - r2);
                        const C2 = (r1 * initialPosition - initialVelocity) / (r1 - r2);
                        position = C1 * Math.exp(r1 * t) + C2 * Math.exp(r2 * t);
                        velocity = C1 * r1 * Math.exp(r1 * t) + C2 * r2 * Math.exp(r2 * t);
                    }

                    this.data.position.push(position);
                    this.data.velocity.push(velocity);

                    const ke = 0.5 * mass * velocity * velocity;
                    const pe = 0.5 * springConstant * position * position;
                    this.data.kineticEnergy.push(ke);
                    this.data.potentialEnergy.push(pe);
                    this.data.totalEnergy.push(ke + pe);
                }
            },

            // Êõ¥Êñ∞Á≥ªÁªü‰ø°ÊÅØ
            updateSystemInfo() {
                const { mass, springConstant, dampingCoefficient } = this.params;
                const omega_n = Math.sqrt(springConstant / mass);
                const zeta = dampingCoefficient / (2 * Math.sqrt(mass * springConstant));

                let dampingType, frequency, period;
                
                if (zeta < 1) {
                    dampingType = 'Ê¨†ÈòªÂ∞º';
                    const omega_d = omega_n * Math.sqrt(1 - zeta * zeta);
                    frequency = (omega_d / (2 * Math.PI)).toFixed(3) + ' Hz';
                    period = (2 * Math.PI / omega_d).toFixed(3) + ' s';
                } else if (Math.abs(zeta - 1) < 0.01) {
                    dampingType = '‰∏¥ÁïåÈòªÂ∞º';
                    frequency = 'N/A';
                    period = 'N/A';
                } else {
                    dampingType = 'ËøáÈòªÂ∞º';
                    frequency = 'N/A';
                    period = 'N/A';
                }

                document.getElementById('damped-dampingType').textContent = dampingType;
                document.getElementById('damped-frequency').textContent = frequency;
                document.getElementById('damped-period').textContent = period;
            },

            // ÁªòÂà∂‰∏ªÂä®Áîª
            drawMainAnimation() {
                const canvas = this.canvases.animation;
                const ctx = this.contexts.animation;
                
                if (!canvas || !ctx) return;

                const width = canvas.width;
                const height = canvas.height;
                
                ctx.clearRect(0, 0, width, height);

                if (this.data.position.length === 0) return;
                
                const index = Math.min(Math.floor(this.state.currentIndex), this.data.position.length - 1);
                const currentPosition = this.data.position[index];
                const currentVelocity = this.data.velocity[index];
                const currentTime = this.data.time[index];

                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, width, height);

                const centerX = width / 2;
                const centerY = height / 2;
                const scale = Math.min(width, height) / 12;

                // ÊîØÊíëÁÇπ
                ctx.fillStyle = '#333';
                ctx.fillRect(centerX - 40, 20, 80, 10);

                // ÂºπÁ∞ß
                ctx.strokeStyle = '#4a90e2';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                const springTop = 30;
                const springBottom = centerY + currentPosition * scale;
                const coils = 12;
                const coilHeight = (springBottom - springTop) / coils;
                
                ctx.moveTo(centerX, springTop);
                for (let i = 0; i < coils; i++) {
                    const y = springTop + i * coilHeight;
                    const nextY = springTop + (i + 1) * coilHeight;
                    const midY = (y + nextY) / 2;
                    
                    if (i % 2 === 0) {
                        ctx.quadraticCurveTo(centerX + 20, midY, centerX, nextY);
                    } else {
                        ctx.quadraticCurveTo(centerX - 20, midY, centerX, nextY);
                    }
                }
                ctx.stroke();

                // Ë¥®ÈáèÂùó
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(centerX - 30, springBottom - 30, 60, 60);
                
                // ÂèÇËÄÉÁ∫ø
                ctx.strokeStyle = '#95a5a6';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(0, centerY);
                ctx.lineTo(width, centerY);
                ctx.stroke();
                ctx.setLineDash([]);

                // ÂΩìÂâçÂÄº
                ctx.fillStyle = '#333';
                ctx.font = '14px Arial';
                ctx.fillText(`‰ΩçÁΩÆ: ${currentPosition.toFixed(3)} m`, 10, height - 40);
                ctx.fillText(`ÈÄüÂ∫¶: ${currentVelocity.toFixed(3)} m/s`, 10, height - 20);

                document.getElementById('damped-currentTime').textContent = currentTime.toFixed(2) + ' s';
            },

            // ÁªòÂà∂ÂõæË°®
            drawDisplacementChart() {
                const ctx = this.contexts.displacement;
                if (!ctx) return;
                this.drawLineChart(ctx, this.data.time, this.data.position, 'Êó∂Èó¥ (s)', '‰ΩçÁßª (m)', '#3498db', true, '#e67e22');
            },

            drawVelocityChart() {
                const ctx = this.contexts.velocity;
                if (!ctx) return;
                this.drawLineChart(ctx, this.data.time, this.data.velocity, 'Êó∂Èó¥ (s)', 'ÈÄüÂ∫¶ (m/s)', '#e74c3c', true, '#3498db');
            },

            drawEnergyChart() {
                const ctx = this.contexts.energy;
                if (!ctx) return;
                
                const canvas = ctx.canvas;
                const width = canvas.width;
                const height = canvas.height;
                
                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, width, height);
                
                this.drawLine(ctx, this.data.time, this.data.kineticEnergy, '#e74c3c', width, height);
                this.drawLine(ctx, this.data.time, this.data.potentialEnergy, '#3498db', width, height);
                this.drawLine(ctx, this.data.time, this.data.totalEnergy, '#2c3e50', width, height);
                
                // Âõæ‰æã
                ctx.font = '12px Arial';
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(width - 100, 20, 15, 15);
                ctx.fillStyle = '#333';
                ctx.fillText('Âä®ËÉΩ', width - 80, 32);
                
                ctx.fillStyle = '#3498db';
                ctx.fillRect(width - 100, 40, 15, 15);
                ctx.fillStyle = '#333';
                ctx.fillText('ÂäøËÉΩ', width - 80, 52);
                
                ctx.fillStyle = '#2c3e50';
                ctx.fillRect(width - 100, 60, 15, 15);
                ctx.fillStyle = '#333';
                ctx.fillText('ÊÄªËÉΩÈáè', width - 80, 72);
            },

            // ÈÄöÁî®ÁªòÂõæÂáΩÊï∞
            drawLineChart(ctx, xData, yData, xLabel, yLabel, color, showMarker = true, markerColor = '#e67e22') {
                const canvas = ctx.canvas;
                const width = canvas.width;
                const height = canvas.height;
                
                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, width, height);
                
                if (xData.length === 0 || yData.length === 0) return;
                
                // ÂùêÊ†áËΩ¥
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(40, height - 30);
                ctx.lineTo(width - 20, height - 30);
                ctx.moveTo(40, height - 30);
                ctx.lineTo(40, 20);
                ctx.stroke();
                
                // Ê†áÁ≠æ
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.fillText(xLabel, width / 2 - 20, height - 5);
                
                ctx.save();
                ctx.translate(15, height / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText(yLabel, 0, 0);
                ctx.restore();
                
                this.drawLine(ctx, xData, yData, color, width, height);
                
                // Ê†áËÆ∞ÂΩìÂâçÁÇπ
                if (showMarker && this.state.currentIndex < xData.length) {
                    const index = Math.floor(this.state.currentIndex);
                    const xMin = Math.min(...xData);
                    const xMax = Math.max(...xData);
                    const yMin = Math.min(...yData);
                    const yMax = Math.max(...yData);
                    
                    const x = 40 + (xData[index] - xMin) / (xMax - xMin) * (width - 60);
                    const y = height - 30 - (yData[index] - yMin) / (yMax - yMin) * (height - 50);
                    
                    ctx.fillStyle = markerColor;
                    ctx.beginPath();
                    ctx.arc(x, y, 5, 0, 2 * Math.PI);
                    ctx.fill();
                }
            },

            drawLine(ctx, xData, yData, color, width, height) {
                if (xData.length === 0 || yData.length === 0) return;
                
                const xMin = Math.min(...xData);
                const xMax = Math.max(...xData);
                const yMin = Math.min(...yData);
                const yMax = Math.max(...yData);
                
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let i = 0; i < xData.length; i++) {
                    const x = 40 + (xData[i] - xMin) / (xMax - xMin) * (width - 60);
                    const y = height - 30 - (yData[i] - yMin) / (yMax - yMin) * (height - 50);
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
            },

            // Âä®ÁîªÊéßÂà∂
            animate() {
                if (!this.state.isPlaying) return;
                
                this.state.currentIndex += this.state.animationSpeed;
                
                if (this.state.currentIndex >= this.data.time.length) {
                    this.state.currentIndex = 0;
                }
                
                this.drawMainAnimation();
                
                if (this.state.chartsVisible) {
                    this.drawCurrentChart();
                }
                
                this.state.animationId = requestAnimationFrame(() => this.animate());
            },

            startAnimation() {
                if (!this.state.isPlaying && this.state.initialized) {
                    this.state.isPlaying = true;
                    document.getElementById('damped-startBtn').disabled = true;
                    document.getElementById('damped-pauseBtn').disabled = false;
                    this.animate();
                }
            },

            pauseAnimation() {
                this.state.isPlaying = false;
                if (this.state.animationId) {
                    cancelAnimationFrame(this.state.animationId);
                }
                document.getElementById('damped-startBtn').disabled = false;
                document.getElementById('damped-pauseBtn').disabled = true;
            },

            resetAnimation() {
                this.pauseAnimation();
                this.state.currentIndex = 0;
                this.calculatePhysics();
                this.updateSystemInfo();
                this.drawMainAnimation();
                if (this.state.chartsVisible) {
                    this.drawCurrentChart();
                }
            },

            toggleCharts() {
                this.state.chartsVisible = !this.state.chartsVisible;
                const chartsContent = document.getElementById('damped-chartsContent');
                const toggleBtn = document.getElementById('damped-toggleChartsBtn');
                
                if (this.state.chartsVisible) {
                    chartsContent.classList.add('active');
                    toggleBtn.textContent = 'ÈöêËóèÂõæË°®';
                    
                    setTimeout(() => {
                        ['displacement', 'velocity', 'energy'].forEach(id => {
                            const canvas = document.getElementById('damped-' + id + 'Canvas');
                            if (canvas) {
                                this.setCanvasSize(canvas);
                                if (!this.contexts[id]) {
                                    this.contexts[id] = canvas.getContext('2d');
                                }
                            }
                        });
                        
                        this.drawDisplacementChart();
                        this.drawVelocityChart();
                        this.drawEnergyChart();
                    }, 50);
                } else {
                    chartsContent.classList.remove('active');
                    toggleBtn.textContent = 'ÊòæÁ§∫ÂõæË°®';
                }
            },

            switchTab(tabName) {
                document.querySelectorAll('#damped-chartsContent .tab-button').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.tab === tabName) {
                        btn.classList.add('active');
                    }
                });
                
                document.querySelectorAll('#damped-chartsContent .chart-canvas').forEach(canvas => {
                    canvas.classList.remove('active');
                });
                
                const targetCanvas = document.getElementById('damped-' + tabName + 'Canvas');
                if (targetCanvas) {
                    targetCanvas.classList.add('active');
                    
                    switch(tabName) {
                        case 'displacement':
                            this.drawDisplacementChart();
                            break;
                        case 'velocity':
                            this.drawVelocityChart();
                            break;
                        case 'energy':
                            this.drawEnergyChart();
                            break;
                    }
                }
            },

            drawCurrentChart() {
                if (!this.state.chartsVisible) return;
                
                const activeCanvas = document.querySelector('#damped-chartsContent .chart-canvas.active');
                if (!activeCanvas) return;
                
                const canvasId = activeCanvas.id;
                
                if (canvasId.includes('displacement')) {
                    this.drawDisplacementChart();
                } else if (canvasId.includes('velocity')) {
                    this.drawVelocityChart();
                } else if (canvasId.includes('energy')) {
                    this.drawEnergyChart();
                }
            },

            // ÂØºÂá∫ËßÜÈ¢ëÔºàÊòæÁ§∫ÈÄâÈ°πËèúÂçïÔºâ
            async exportVideo() {
                const statusEl = document.getElementById('damped-exportStatus');
                const exportBtn = document.getElementById('damped-exportBtn');
                
                // Ê£ÄÊµãÊòØÂê¶‰∏∫ÁßªÂä®ËÆæÂ§á
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                
                // ÂàõÂª∫ÂØºÂá∫ÈÄâÈ°πËèúÂçïÔºàÁßªÂä®Á´Ø‰ºòÂåñÔºâ
                const options = `
                    <div style="margin-bottom: 10px; font-weight: bold; font-size: ${isMobile ? '14px' : '16px'};">ÈÄâÊã©Ë¶ÅÂØºÂá∫ÁöÑËßÜÈ¢ëÔºö</div>
                    <div style="display: flex; flex-wrap: wrap; gap: 5px;">
                        <button onclick="dampedSim.exportSpecificVideo('animation')" 
                            style="flex: ${isMobile ? '1 1 45%' : '1'}; 
                                   margin: 2px; 
                                   padding: ${isMobile ? '12px 8px' : '8px'}; 
                                   font-size: ${isMobile ? '13px' : '14px'}; 
                                   border: 1px solid #ddd; 
                                   border-radius: 5px; 
                                   background: white; 
                                   cursor: pointer;">‰∏ªÂä®Áîª</button>
                        <button onclick="dampedSim.exportSpecificVideo('displacement')" 
                            style="flex: ${isMobile ? '1 1 45%' : '1'}; 
                                   margin: 2px; 
                                   padding: ${isMobile ? '12px 8px' : '8px'}; 
                                   font-size: ${isMobile ? '13px' : '14px'}; 
                                   border: 1px solid #ddd; 
                                   border-radius: 5px; 
                                   background: white; 
                                   cursor: pointer;">‰ΩçÁßªÂõæ</button>
                        <button onclick="dampedSim.exportSpecificVideo('velocity')" 
                            style="flex: ${isMobile ? '1 1 45%' : '1'}; 
                                   margin: 2px; 
                                   padding: ${isMobile ? '12px 8px' : '8px'}; 
                                   font-size: ${isMobile ? '13px' : '14px'}; 
                                   border: 1px solid #ddd; 
                                   border-radius: 5px; 
                                   background: white; 
                                   cursor: pointer;">ÈÄüÂ∫¶Âõæ</button>
                        <button onclick="dampedSim.exportSpecificVideo('energy')" 
                            style="flex: ${isMobile ? '1 1 45%' : '1'}; 
                                   margin: 2px; 
                                   padding: ${isMobile ? '12px 8px' : '8px'}; 
                                   font-size: ${isMobile ? '13px' : '14px'}; 
                                   border: 1px solid #ddd; 
                                   border-radius: 5px; 
                                   background: white; 
                                   cursor: pointer;">ËÉΩÈáèÂõæ</button>
                        <button onclick="dampedSim.exportSpecificVideo('all')" 
                            style="flex: ${isMobile ? '1 1 45%' : '1'}; 
                                   margin: 2px; 
                                   padding: ${isMobile ? '12px 8px' : '8px'}; 
                                   font-size: ${isMobile ? '13px' : '14px'}; 
                                   background: #27ae60; 
                                   color: white; 
                                   border: none; 
                                   border-radius: 5px; 
                                   cursor: pointer;">ÂØºÂá∫ÂÖ®ÈÉ®</button>
                        <button onclick="dampedSim.cancelExport()" 
                            style="flex: ${isMobile ? '1 1 100%' : '1'}; 
                                   margin: 2px; 
                                   padding: ${isMobile ? '12px 8px' : '8px'}; 
                                   font-size: ${isMobile ? '13px' : '14px'}; 
                                   background: #e74c3c; 
                                   color: white; 
                                   border: none; 
                                   border-radius: 5px; 
                                   cursor: pointer;">ÂèñÊ∂à</button>
                    </div>
                `;
                
                statusEl.innerHTML = options;
                statusEl.className = 'export-status active';
            },
            
            // ÂèñÊ∂àÂØºÂá∫
            cancelExport() {
                const statusEl = document.getElementById('damped-exportStatus');
                statusEl.classList.remove('active');
            },
            
            // ÂØºÂá∫ÁâπÂÆöËßÜÈ¢ë
            async exportSpecificVideo(videoType) {
                const statusEl = document.getElementById('damped-exportStatus');
                const exportBtn = document.getElementById('damped-exportBtn');
                
                try {
                    // ÊöÇÂÅúÂä®Áîª
                    const wasPlaying = this.state.isPlaying;
                    this.pauseAnimation();
                    
                    // Á°Æ‰øùÊâÄÊúâÂõæË°®ÈÉΩÊòæÁ§∫ÔºàÂ¶ÇÊûúÈúÄË¶ÅÔºâ
                    if (videoType !== 'animation' && !this.state.chartsVisible) {
                        this.toggleCharts();
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                    
                    if (videoType === 'all') {
                        // ÂØºÂá∫ÊâÄÊúâËßÜÈ¢ë
                        statusEl.className = 'export-status active recording';
                        statusEl.textContent = 'üî¥ Ê≠£Âú®ÂØºÂá∫ÊâÄÊúâËßÜÈ¢ë...';
                        exportBtn.disabled = true;
                        
                        await this.exporter.exportAllVideos(this);
                        
                        statusEl.className = 'export-status active success';
                        statusEl.textContent = '‚úÖ ÊâÄÊúâËßÜÈ¢ëÂØºÂá∫ÊàêÂäüÔºÅ';
                    } else {
                        // ÂØºÂá∫Âçï‰∏™ËßÜÈ¢ë
                        statusEl.className = 'export-status active recording';
                        statusEl.textContent = `üî¥ Ê≠£Âú®ÂØºÂá∫${this.getVideoTypeName(videoType)}...`;
                        exportBtn.disabled = true;
                        
                        await this.exporter.exportSingleVideo(this, videoType);
                        
                        statusEl.className = 'export-status active success';
                        statusEl.textContent = `‚úÖ ${this.getVideoTypeName(videoType)}ÂØºÂá∫ÊàêÂäüÔºÅ`;
                    }
                    
                    // ÊÅ¢Â§çÂä®ÁîªÁä∂ÊÄÅ
                    if (wasPlaying) {
                        this.startAnimation();
                    }
                    
                } catch (error) {
                    console.error('ÂØºÂá∫Â§±Ë¥•:', error);
                    statusEl.className = 'export-status active error';
                    statusEl.textContent = '‚ùå ÂØºÂá∫Â§±Ë¥•: ' + error.message;
                } finally {
                    exportBtn.disabled = false;
                    
                    // 3ÁßíÂêéÈöêËóèÁä∂ÊÄÅ
                    setTimeout(() => {
                        statusEl.classList.remove('active');
                    }, 3000);
                }
            },
            
            // Ëé∑ÂèñËßÜÈ¢ëÁ±ªÂûãÂêçÁß∞
            getVideoTypeName(videoType) {
                const names = {
                    'animation': '‰∏ªÂä®ÁîªËßÜÈ¢ë',
                    'displacement': '‰ΩçÁßªÂõæËßÜÈ¢ë',
                    'velocity': 'ÈÄüÂ∫¶ÂõæËßÜÈ¢ë',
                    'energy': 'ËÉΩÈáèÂõæËßÜÈ¢ë'
                };
                return names[videoType] || videoType;
            }
        };

        // ============= ÂèóËø´ÊåØÂä®Ê®°ÊãüÂô® =============
        const forcedSim = {
            // Áä∂ÊÄÅ
            state: {
                isPlaying: false,
                currentIndex: 0,
                animationId: null,
                animationSpeed: 1.0,
                chartsVisible: false,
                initialized: false
            },

            // Áâ©ÁêÜÂèÇÊï∞
            params: {
                mass: 1,
                springConstant: 10,
                dampingCoefficient: 0.5,
                forceAmplitude: 2,
                forceFrequency: 3,
                initialPosition: 0,
                initialVelocity: 0
            },

            // Êï∞ÊçÆ
            data: {
                time: [],
                position: [],
                velocity: [],
                force: [],
                kineticEnergy: [],
                potentialEnergy: [],
                totalEnergy: []
            },

            // ÂÖ±ÊåØÊï∞ÊçÆ
            resonanceData: {
                frequencies: [],
                amplitudes: [],
                phases: []
            },

            // CanvasÂºïÁî®
            canvases: {},
            contexts: {},

            // ËßÜÈ¢ëÂØºÂá∫Âô®
            exporter: null,

            // ÂàùÂßãÂåñ
            init() {
                this.initializeCanvases();
                this.setupEventListeners();
                this.calculatePhysics();
                this.calculateResonanceCurve();
                this.updateSystemInfo();
                this.drawMainAnimation();
                this.exporter = new VideoExporter('forced');
                this.state.initialized = true;
            },

            // ÂàùÂßãÂåñCanvas
            initializeCanvases() {
                const animCanvas = document.getElementById('forced-animationCanvas');
                if (animCanvas) {
                    this.canvases.animation = animCanvas;
                    this.contexts.animation = animCanvas.getContext('2d');
                    this.setCanvasSize(animCanvas);
                }

                ['displacement', 'velocity', 'energy', 'resonance'].forEach(id => {
                    const canvas = document.getElementById('forced-' + id + 'Canvas');
                    if (canvas) {
                        this.canvases[id] = canvas;
                        this.contexts[id] = canvas.getContext('2d');
                        this.setCanvasSize(canvas);
                    }
                });
            },

            setCanvasSize(canvas) {
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height;
            },

            handleResize() {
                Object.values(this.canvases).forEach(canvas => {
                    if (canvas) this.setCanvasSize(canvas);
                });
                this.drawMainAnimation();
                if (this.state.chartsVisible) {
                    this.drawCurrentChart();
                }
            },

            setupEventListeners() {
                const self = this;
                
                document.getElementById('forced-startBtn').addEventListener('click', () => self.startAnimation());
                document.getElementById('forced-pauseBtn').addEventListener('click', () => self.pauseAnimation());
                document.getElementById('forced-resetBtn').addEventListener('click', () => self.resetAnimation());
                document.getElementById('forced-toggleChartsBtn').addEventListener('click', () => self.toggleCharts());
                document.getElementById('forced-exportBtn').addEventListener('click', () => self.exportVideo());

                document.querySelectorAll('#forced-chartsContent .tab-button').forEach(btn => {
                    btn.addEventListener('click', function() {
                        self.switchTab(this.dataset.tab);
                    });
                });

                this.setupParameterListeners();

                const speedSlider = document.getElementById('forced-speedSlider');
                speedSlider.addEventListener('input', function() {
                    self.state.animationSpeed = parseFloat(this.value);
                    document.getElementById('forced-speedDisplay').textContent = self.state.animationSpeed.toFixed(1) + 'x';
                });
            },

            setupParameterListeners() {
                const self = this;
                const parameters = [
                    { slider: 'forced-massSlider', input: 'forced-massInput', param: 'mass' },
                    { slider: 'forced-springSlider', input: 'forced-springInput', param: 'springConstant' },
                    { slider: 'forced-dampingSlider', input: 'forced-dampingInput', param: 'dampingCoefficient' },
                    { slider: 'forced-forceSlider', input: 'forced-forceInput', param: 'forceAmplitude' },
                    { slider: 'forced-frequencySlider', input: 'forced-frequencyInput', param: 'forceFrequency' },
                    { slider: 'forced-positionSlider', input: 'forced-positionInput', param: 'initialPosition' },
                    { slider: 'forced-velocitySlider', input: 'forced-velocityInput', param: 'initialVelocity' }
                ];

                parameters.forEach(({ slider, input, param }) => {
                    const sliderEl = document.getElementById(slider);
                    const inputEl = document.getElementById(input);

                    sliderEl.addEventListener('input', function() {
                        inputEl.value = this.value;
                        self.params[param] = parseFloat(this.value);
                        self.resetAnimation();
                    });

                    inputEl.addEventListener('change', function() {
                        sliderEl.value = this.value;
                        self.params[param] = parseFloat(this.value);
                        self.resetAnimation();
                    });
                });
            },

            calculatePhysics() {
                Object.keys(this.data).forEach(key => {
                    this.data[key] = [];
                });

                const { mass, springConstant, dampingCoefficient, forceAmplitude, forceFrequency, initialPosition, initialVelocity } = this.params;

                const dt = 0.02;
                const t_max = 30;

                let position = initialPosition;
                let velocity = initialVelocity;

                for (let t = 0; t <= t_max; t += dt) {
                    this.data.time.push(t);
                    this.data.position.push(position);
                    this.data.velocity.push(velocity);

                    const force = forceAmplitude * Math.cos(forceFrequency * t);
                    this.data.force.push(force);

                    const ke = 0.5 * mass * velocity * velocity;
                    const pe = 0.5 * springConstant * position * position;
                    this.data.kineticEnergy.push(ke);
                    this.data.potentialEnergy.push(pe);
                    this.data.totalEnergy.push(ke + pe);

                    const acceleration = (force - dampingCoefficient * velocity - springConstant * position) / mass;
                    velocity += acceleration * dt;
                    position += velocity * dt;
                }
            },

            calculateResonanceCurve() {
                this.resonanceData.frequencies = [];
                this.resonanceData.amplitudes = [];
                this.resonanceData.phases = [];

                const { mass, springConstant, dampingCoefficient, forceAmplitude } = this.params;
                const omega_n = Math.sqrt(springConstant / mass);
                const zeta = dampingCoefficient / (2 * Math.sqrt(mass * springConstant));

                const omegaMin = 0.1 * omega_n;
                const omegaMax = 3 * omega_n;
                const numPoints = 100;

                for (let i = 0; i < numPoints; i++) {
                    const omega = omegaMin + (omegaMax - omegaMin) * i / (numPoints - 1);
                    const r = omega / omega_n;

                    const denominator = Math.sqrt(Math.pow(1 - r * r, 2) + Math.pow(2 * zeta * r, 2));
                    const amplitude = (forceAmplitude / springConstant) / denominator;
                    const phase = Math.atan2(2 * zeta * r, 1 - r * r);

                    this.resonanceData.frequencies.push(omega);
                    this.resonanceData.amplitudes.push(amplitude);
                    this.resonanceData.phases.push(phase);
                }
            },

            updateSystemInfo() {
                const { mass, springConstant, dampingCoefficient, forceAmplitude, forceFrequency } = this.params;
                
                const omega_n = Math.sqrt(springConstant / mass);
                const zeta = dampingCoefficient / (2 * Math.sqrt(mass * springConstant));
                const frequencyRatio = forceFrequency / omega_n;

                const denominator = Math.sqrt(Math.pow(springConstant - mass * forceFrequency * forceFrequency, 2) + 
                                             Math.pow(dampingCoefficient * forceFrequency, 2));
                const steadyAmplitude = forceAmplitude / denominator;
                const phase = Math.atan2(dampingCoefficient * forceFrequency, springConstant - mass * forceFrequency * forceFrequency);

                document.getElementById('forced-naturalFrequency').textContent = omega_n.toFixed(3) + ' rad/s';
                document.getElementById('forced-frequencyRatio').textContent = frequencyRatio.toFixed(3);
                document.getElementById('forced-steadyAmplitude').textContent = steadyAmplitude.toFixed(3) + ' m';
                document.getElementById('forced-phaseDifference').textContent = (phase * 180 / Math.PI).toFixed(1) + '¬∞';
            },

            drawMainAnimation() {
                const canvas = this.canvases.animation;
                const ctx = this.contexts.animation;
                
                if (!canvas || !ctx) return;

                const width = canvas.width;
                const height = canvas.height;
                
                ctx.clearRect(0, 0, width, height);

                if (this.data.position.length === 0) return;
                
                const index = Math.min(Math.floor(this.state.currentIndex), this.data.position.length - 1);
                const currentPosition = this.data.position[index];
                const currentVelocity = this.data.velocity[index];
                const currentForce = this.data.force[index];
                const currentTime = this.data.time[index];

                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, width, height);

                const centerX = width / 2;
                const centerY = height / 2;
                const scale = Math.min(width, height) / 12;

                // ÊîØÊíëÁÇπ
                ctx.fillStyle = '#333';
                ctx.fillRect(centerX - 40, 20, 80, 10);

                // ÂºπÁ∞ß
                ctx.strokeStyle = '#4a90e2';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                const springTop = 30;
                const springBottom = centerY + currentPosition * scale;
                const coils = 12;
                const coilHeight = (springBottom - springTop) / coils;
                
                ctx.moveTo(centerX, springTop);
                for (let i = 0; i < coils; i++) {
                    const y = springTop + i * coilHeight;
                    const nextY = springTop + (i + 1) * coilHeight;
                    const midY = (y + nextY) / 2;
                    
                    if (i % 2 === 0) {
                        ctx.quadraticCurveTo(centerX + 20, midY, centerX, nextY);
                    } else {
                        ctx.quadraticCurveTo(centerX - 20, midY, centerX, nextY);
                    }
                }
                ctx.stroke();

                // Ë¥®ÈáèÂùó
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(centerX - 30, springBottom - 30, 60, 60);
                
                // Â§ñÂäõÁÆ≠Â§¥Ôºà‰øÆÊ≠£‰∏∫ÂûÇÁõ¥ÊñπÂêëÔºâ
                const forceScale = 15;
                const forceLength = currentForce * forceScale;
                const forceX = centerX;
                const forceBaseY = springBottom;
                
                ctx.strokeStyle = '#27ae60';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(forceX, forceBaseY);
                ctx.lineTo(forceX, forceBaseY + forceLength);
                ctx.stroke();
                
                // ÁªòÂà∂ÁÆ≠Â§¥Â§¥ÈÉ®
                if (Math.abs(forceLength) > 5) {
                    ctx.beginPath();
                    const arrowDir = forceLength > 0 ? 1 : -1;
                    ctx.moveTo(forceX, forceBaseY + forceLength);
                    ctx.lineTo(forceX - 5, forceBaseY + forceLength - 10 * arrowDir);
                    ctx.lineTo(forceX + 5, forceBaseY + forceLength - 10 * arrowDir);
                    ctx.closePath();
                    ctx.fillStyle = '#27ae60';
                    ctx.fill();
                }
                
                // Âú®ÁÆ≠Â§¥ÊóÅËæπÊ∑ªÂä†"F"Ê†áÁ≠æ
                ctx.fillStyle = '#27ae60';
                ctx.font = 'bold 14px Arial';
                ctx.fillText('F', forceX + 15, forceBaseY + forceLength / 2);
                
                // ÂèÇËÄÉÁ∫ø
                ctx.strokeStyle = '#95a5a6';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(0, centerY);
                ctx.lineTo(width, centerY);
                ctx.stroke();
                ctx.setLineDash([]);

                // ÂΩìÂâçÂÄº
                ctx.fillStyle = '#333';
                ctx.font = '14px Arial';
                ctx.fillText(`‰ΩçÁΩÆ: ${currentPosition.toFixed(3)} m`, 10, height - 60);
                ctx.fillText(`ÈÄüÂ∫¶: ${currentVelocity.toFixed(3)} m/s`, 10, height - 40);
                ctx.fillText(`Â§ñÂäõ: ${currentForce.toFixed(3)} N`, 10, height - 20);

                document.getElementById('forced-currentTime').textContent = currentTime.toFixed(2) + ' s';
                document.getElementById('forced-currentForce').textContent = currentForce.toFixed(2) + ' N';
            },

            drawDisplacementChart() {
                const ctx = this.contexts.displacement;
                if (!ctx) return;
                
                const canvas = ctx.canvas;
                const width = canvas.width;
                const height = canvas.height;
                
                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, width, height);
                
                const scale = 0.3;
                const scaledForce = this.data.force.map(f => f * scale);
                
                this.drawLine(ctx, this.data.time, this.data.position, '#3498db', width, height);
                this.drawLine(ctx, this.data.time, scaledForce, '#27ae60', width, height);
                
                // Ê†áËÆ∞ÂΩìÂâçÁÇπ
                if (this.state.currentIndex < this.data.time.length) {
                    const index = Math.floor(this.state.currentIndex);
                    const xMin = Math.min(...this.data.time);
                    const xMax = Math.max(...this.data.time);
                    const yMin = Math.min(...this.data.position, ...scaledForce);
                    const yMax = Math.max(...this.data.position, ...scaledForce);
                    
                    const x = 40 + (this.data.time[index] - xMin) / (xMax - xMin) * (width - 60);
                    const y1 = height - 30 - (this.data.position[index] - yMin) / (yMax - yMin) * (height - 50);
                    const y2 = height - 30 - (scaledForce[index] - yMin) / (yMax - yMin) * (height - 50);
                    
                    ctx.fillStyle = '#e67e22';
                    ctx.beginPath();
                    ctx.arc(x, y1, 5, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    ctx.fillStyle = '#95a5a6';
                    ctx.beginPath();
                    ctx.arc(x, y2, 4, 0, 2 * Math.PI);
                    ctx.fill();
                }
                
                // Âõæ‰æã
                ctx.font = '12px Arial';
                ctx.fillStyle = '#3498db';
                ctx.fillRect(width - 120, 20, 15, 15);
                ctx.fillStyle = '#333';
                ctx.fillText('‰ΩçÁßª', width - 100, 32);
                
                ctx.fillStyle = '#27ae60';
                ctx.fillRect(width - 120, 40, 15, 15);
                ctx.fillStyle = '#333';
                ctx.fillText('Â§ñÂäõ√ó0.3', width - 100, 52);
                
                ctx.fillStyle = '#333';
                ctx.fillText('Êó∂Èó¥ (s)', width / 2 - 20, height - 5);
            },

            drawVelocityChart() {
                const ctx = this.contexts.velocity;
                if (!ctx) return;
                this.drawLineChart(ctx, this.data.time, this.data.velocity, 'Êó∂Èó¥ (s)', 'ÈÄüÂ∫¶ (m/s)', '#e74c3c', true, '#3498db');
            },

            drawEnergyChart() {
                const ctx = this.contexts.energy;
                if (!ctx) return;
                
                const canvas = ctx.canvas;
                const width = canvas.width;
                const height = canvas.height;
                
                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, width, height);
                
                this.drawLine(ctx, this.data.time, this.data.kineticEnergy, '#e74c3c', width, height);
                this.drawLine(ctx, this.data.time, this.data.potentialEnergy, '#3498db', width, height);
                this.drawLine(ctx, this.data.time, this.data.totalEnergy, '#2c3e50', width, height);
                
                // Âõæ‰æã
                ctx.font = '12px Arial';
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(width - 100, 20, 15, 15);
                ctx.fillStyle = '#333';
                ctx.fillText('Âä®ËÉΩ', width - 80, 32);
                
                ctx.fillStyle = '#3498db';
                ctx.fillRect(width - 100, 40, 15, 15);
                ctx.fillStyle = '#333';
                ctx.fillText('ÂäøËÉΩ', width - 80, 52);
                
                ctx.fillStyle = '#2c3e50';
                ctx.fillRect(width - 100, 60, 15, 15);
                ctx.fillStyle = '#333';
                ctx.fillText('ÊÄªËÉΩÈáè', width - 80, 72);
            },

            drawResonanceChart() {
                const ctx = this.contexts.resonance;
                if (!ctx) return;
                
                const canvas = ctx.canvas;
                const width = canvas.width;
                const height = canvas.height;
                
                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, width, height);
                
                const omega_n = Math.sqrt(this.params.springConstant / this.params.mass);
                const frequencyRatios = this.resonanceData.frequencies.map(f => f / omega_n);
                
                this.drawLine(ctx, frequencyRatios, this.resonanceData.amplitudes, '#e74c3c', width, height);
                
                // Ê†áËÆ∞ÂΩìÂâçÂ∑•‰ΩúÁÇπ
                const currentRatio = this.params.forceFrequency / omega_n;
                const denominator = Math.sqrt(Math.pow(this.params.springConstant - this.params.mass * this.params.forceFrequency * this.params.forceFrequency, 2) + 
                                             Math.pow(this.params.dampingCoefficient * this.params.forceFrequency, 2));
                const currentAmplitude = this.params.forceAmplitude / denominator;
                
                const xMin = Math.min(...frequencyRatios);
                const xMax = Math.max(...frequencyRatios);
                const yMin = Math.min(...this.resonanceData.amplitudes);
                const yMax = Math.max(...this.resonanceData.amplitudes);
                
                const x = 40 + (currentRatio - xMin) / (xMax - xMin) * (width - 60);
                const y = height - 30 - (currentAmplitude - yMin) / (yMax - yMin) * (height - 50);
                
                ctx.fillStyle = '#27ae60';
                ctx.beginPath();
                ctx.arc(x, y, 6, 0, 2 * Math.PI);
                ctx.fill();
                
                // ÂÖ±ÊåØÈ¢ëÁéáÁ∫ø
                ctx.strokeStyle = '#95a5a6';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                const resonanceX = 40 + (1 - xMin) / (xMax - xMin) * (width - 60);
                ctx.moveTo(resonanceX, 20);
                ctx.lineTo(resonanceX, height - 30);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Ê†áÁ≠æ
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.fillText('È¢ëÁéáÊØî (œâ/œân)', width / 2 - 30, height - 5);
                
                ctx.save();
                ctx.translate(15, height / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText('ÊåØÂπÖ (m)', 0, 0);
                ctx.restore();
                
                // Âõæ‰æã
                ctx.fillStyle = '#27ae60';
                ctx.fillRect(width - 120, 20, 15, 15);
                ctx.fillStyle = '#333';
                ctx.fillText('ÂΩìÂâçÂ∑•‰ΩúÁÇπ', width - 100, 32);
            },

            drawLineChart(ctx, xData, yData, xLabel, yLabel, color, showMarker = true, markerColor = '#e67e22') {
                const canvas = ctx.canvas;
                const width = canvas.width;
                const height = canvas.height;
                
                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, width, height);
                
                if (xData.length === 0 || yData.length === 0) return;
                
                // ÂùêÊ†áËΩ¥
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(40, height - 30);
                ctx.lineTo(width - 20, height - 30);
                ctx.moveTo(40, height - 30);
                ctx.lineTo(40, 20);
                ctx.stroke();
                
                // Ê†áÁ≠æ
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.fillText(xLabel, width / 2 - 20, height - 5);
                
                ctx.save();
                ctx.translate(15, height / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText(yLabel, 0, 0);
                ctx.restore();
                
                this.drawLine(ctx, xData, yData, color, width, height);
                
                // Ê†áËÆ∞ÂΩìÂâçÁÇπ
                if (showMarker && this.state.currentIndex < xData.length) {
                    const index = Math.floor(this.state.currentIndex);
                    const xMin = Math.min(...xData);
                    const xMax = Math.max(...xData);
                    const yMin = Math.min(...yData);
                    const yMax = Math.max(...yData);
                    
                    const x = 40 + (xData[index] - xMin) / (xMax - xMin) * (width - 60);
                    const y = height - 30 - (yData[index] - yMin) / (yMax - yMin) * (height - 50);
                    
                    ctx.fillStyle = markerColor;
                    ctx.beginPath();
                    ctx.arc(x, y, 5, 0, 2 * Math.PI);
                    ctx.fill();
                }
            },

            drawLine(ctx, xData, yData, color, width, height) {
                if (xData.length === 0 || yData.length === 0) return;
                
                const xMin = Math.min(...xData);
                const xMax = Math.max(...xData);
                const yMin = Math.min(...yData);
                const yMax = Math.max(...yData);
                
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let i = 0; i < xData.length; i++) {
                    const x = 40 + (xData[i] - xMin) / (xMax - xMin) * (width - 60);
                    const y = height - 30 - (yData[i] - yMin) / (yMax - yMin) * (height - 50);
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
            },

            animate() {
                if (!this.state.isPlaying) return;
                
                this.state.currentIndex += this.state.animationSpeed;
                
                if (this.state.currentIndex >= this.data.time.length) {
                    this.state.currentIndex = 0;
                }
                
                this.drawMainAnimation();
                
                if (this.state.chartsVisible) {
                    this.drawCurrentChart();
                }
                
                this.state.animationId = requestAnimationFrame(() => this.animate());
            },

            startAnimation() {
                if (!this.state.isPlaying && this.state.initialized) {
                    this.state.isPlaying = true;
                    document.getElementById('forced-startBtn').disabled = true;
                    document.getElementById('forced-pauseBtn').disabled = false;
                    this.animate();
                }
            },

            pauseAnimation() {
                this.state.isPlaying = false;
                if (this.state.animationId) {
                    cancelAnimationFrame(this.state.animationId);
                }
                document.getElementById('forced-startBtn').disabled = false;
                document.getElementById('forced-pauseBtn').disabled = true;
            },

            resetAnimation() {
                this.pauseAnimation();
                this.state.currentIndex = 0;
                this.calculatePhysics();
                this.calculateResonanceCurve();
                this.updateSystemInfo();
                this.drawMainAnimation();
                if (this.state.chartsVisible) {
                    this.drawCurrentChart();
                }
            },

            toggleCharts() {
                this.state.chartsVisible = !this.state.chartsVisible;
                const chartsContent = document.getElementById('forced-chartsContent');
                const toggleBtn = document.getElementById('forced-toggleChartsBtn');
                
                if (this.state.chartsVisible) {
                    chartsContent.classList.add('active');
                    toggleBtn.textContent = 'ÈöêËóèÂõæË°®';
                    
                    setTimeout(() => {
                        ['displacement', 'velocity', 'energy', 'resonance'].forEach(id => {
                            const canvas = document.getElementById('forced-' + id + 'Canvas');
                            if (canvas) {
                                this.setCanvasSize(canvas);
                                if (!this.contexts[id]) {
                                    this.contexts[id] = canvas.getContext('2d');
                                }
                            }
                        });
                        
                        this.drawDisplacementChart();
                        this.drawVelocityChart();
                        this.drawEnergyChart();
                        this.drawResonanceChart();
                    }, 50);
                } else {
                    chartsContent.classList.remove('active');
                    toggleBtn.textContent = 'ÊòæÁ§∫ÂõæË°®';
                }
            },

            switchTab(tabName) {
                document.querySelectorAll('#forced-chartsContent .tab-button').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.tab === tabName) {
                        btn.classList.add('active');
                    }
                });
                
                document.querySelectorAll('#forced-chartsContent .chart-canvas').forEach(canvas => {
                    canvas.classList.remove('active');
                });
                
                const targetCanvas = document.getElementById('forced-' + tabName + 'Canvas');
                if (targetCanvas) {
                    targetCanvas.classList.add('active');
                    
                    switch(tabName) {
                        case 'displacement':
                            this.drawDisplacementChart();
                            break;
                        case 'velocity':
                            this.drawVelocityChart();
                            break;
                        case 'energy':
                            this.drawEnergyChart();
                            break;
                        case 'resonance':
                            this.drawResonanceChart();
                            break;
                    }
                }
            },

            drawCurrentChart() {
                if (!this.state.chartsVisible) return;
                
                const activeCanvas = document.querySelector('#forced-chartsContent .chart-canvas.active');
                if (!activeCanvas) return;
                
                const canvasId = activeCanvas.id;
                
                if (canvasId.includes('displacement')) {
                    this.drawDisplacementChart();
                } else if (canvasId.includes('velocity')) {
                    this.drawVelocityChart();
                } else if (canvasId.includes('energy')) {
                    this.drawEnergyChart();
                } else if (canvasId.includes('resonance')) {
                    this.drawResonanceChart();
                }
            },

            // ÂØºÂá∫ËßÜÈ¢ëÔºàÊòæÁ§∫ÈÄâÈ°πËèúÂçïÔºâ
            async exportVideo() {
                const statusEl = document.getElementById('forced-exportStatus');
                const exportBtn = document.getElementById('forced-exportBtn');
                
                // Ê£ÄÊµãÊòØÂê¶‰∏∫ÁßªÂä®ËÆæÂ§á
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                
                // ÂàõÂª∫ÂØºÂá∫ÈÄâÈ°πËèúÂçïÔºàÁßªÂä®Á´Ø‰ºòÂåñÔºâ
                const options = `
                    <div style="margin-bottom: 10px; font-weight: bold; font-size: ${isMobile ? '14px' : '16px'};">ÈÄâÊã©Ë¶ÅÂØºÂá∫ÁöÑËßÜÈ¢ëÔºö</div>
                    <div style="display: flex; flex-wrap: wrap; gap: 5px;">
                        <button onclick="forcedSim.exportSpecificVideo('animation')" 
                            style="flex: ${isMobile ? '1 1 45%' : '1'}; 
                                   margin: 2px; 
                                   padding: ${isMobile ? '12px 8px' : '8px'}; 
                                   font-size: ${isMobile ? '13px' : '14px'}; 
                                   border: 1px solid #ddd; 
                                   border-radius: 5px; 
                                   background: white; 
                                   cursor: pointer;">‰∏ªÂä®Áîª</button>
                        <button onclick="forcedSim.exportSpecificVideo('displacement')" 
                            style="flex: ${isMobile ? '1 1 45%' : '1'}; 
                                   margin: 2px; 
                                   padding: ${isMobile ? '12px 8px' : '8px'}; 
                                   font-size: ${isMobile ? '13px' : '14px'}; 
                                   border: 1px solid #ddd; 
                                   border-radius: 5px; 
                                   background: white; 
                                   cursor: pointer;">‰ΩçÁßªÂõæ</button>
                        <button onclick="forcedSim.exportSpecificVideo('velocity')" 
                            style="flex: ${isMobile ? '1 1 45%' : '1'}; 
                                   margin: 2px; 
                                   padding: ${isMobile ? '12px 8px' : '8px'}; 
                                   font-size: ${isMobile ? '13px' : '14px'}; 
                                   border: 1px solid #ddd; 
                                   border-radius: 5px; 
                                   background: white; 
                                   cursor: pointer;">ÈÄüÂ∫¶Âõæ</button>
                        <button onclick="forcedSim.exportSpecificVideo('energy')" 
                            style="flex: ${isMobile ? '1 1 45%' : '1'}; 
                                   margin: 2px; 
                                   padding: ${isMobile ? '12px 8px' : '8px'}; 
                                   font-size: ${isMobile ? '13px' : '14px'}; 
                                   border: 1px solid #ddd; 
                                   border-radius: 5px; 
                                   background: white; 
                                   cursor: pointer;">ËÉΩÈáèÂõæ</button>
                        <button onclick="forcedSim.exportSpecificVideo('resonance')" 
                            style="flex: ${isMobile ? '1 1 45%' : '1'}; 
                                   margin: 2px; 
                                   padding: ${isMobile ? '12px 8px' : '8px'}; 
                                   font-size: ${isMobile ? '13px' : '14px'}; 
                                   border: 1px solid #ddd; 
                                   border-radius: 5px; 
                                   background: white; 
                                   cursor: pointer;">ÂÖ±ÊåØÊõ≤Á∫ø</button>
                        <button onclick="forcedSim.exportSpecificVideo('all')" 
                            style="flex: ${isMobile ? '1 1 45%' : '1'}; 
                                   margin: 2px; 
                                   padding: ${isMobile ? '12px 8px' : '8px'}; 
                                   font-size: ${isMobile ? '13px' : '14px'}; 
                                   background: #27ae60; 
                                   color: white; 
                                   border: none; 
                                   border-radius: 5px; 
                                   cursor: pointer;">ÂØºÂá∫ÂÖ®ÈÉ®</button>
                        <button onclick="forcedSim.cancelExport()" 
                            style="flex: ${isMobile ? '1 1 100%' : '1'}; 
                                   margin: 2px; 
                                   padding: ${isMobile ? '12px 8px' : '8px'}; 
                                   font-size: ${isMobile ? '13px' : '14px'}; 
                                   background: #e74c3c; 
                                   color: white; 
                                   border: none; 
                                   border-radius: 5px; 
                                   cursor: pointer;">ÂèñÊ∂à</button>
                    </div>
                `;
                
                statusEl.innerHTML = options;
                statusEl.className = 'export-status active';
            },
            
            // ÂèñÊ∂àÂØºÂá∫
            cancelExport() {
                const statusEl = document.getElementById('forced-exportStatus');
                statusEl.classList.remove('active');
            },
            
            // ÂØºÂá∫ÁâπÂÆöËßÜÈ¢ë
            async exportSpecificVideo(videoType) {
                const statusEl = document.getElementById('forced-exportStatus');
                const exportBtn = document.getElementById('forced-exportBtn');
                
                try {
                    // ÊöÇÂÅúÂä®Áîª
                    const wasPlaying = this.state.isPlaying;
                    this.pauseAnimation();
                    
                    // Á°Æ‰øùÊâÄÊúâÂõæË°®ÈÉΩÊòæÁ§∫ÔºàÂ¶ÇÊûúÈúÄË¶ÅÔºâ
                    if (videoType !== 'animation' && !this.state.chartsVisible) {
                        this.toggleCharts();
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                    
                    if (videoType === 'all') {
                        // ÂØºÂá∫ÊâÄÊúâËßÜÈ¢ë
                        statusEl.className = 'export-status active recording';
                        statusEl.textContent = 'üî¥ Ê≠£Âú®ÂØºÂá∫ÊâÄÊúâËßÜÈ¢ë...';
                        exportBtn.disabled = true;
                        
                        await this.exporter.exportAllVideos(this);
                        
                        statusEl.className = 'export-status active success';
                        statusEl.textContent = '‚úÖ ÊâÄÊúâËßÜÈ¢ëÂØºÂá∫ÊàêÂäüÔºÅ';
                    } else {
                        // ÂØºÂá∫Âçï‰∏™ËßÜÈ¢ë
                        statusEl.className = 'export-status active recording';
                        statusEl.textContent = `üî¥ Ê≠£Âú®ÂØºÂá∫${this.getVideoTypeName(videoType)}...`;
                        exportBtn.disabled = true;
                        
                        await this.exporter.exportSingleVideo(this, videoType);
                        
                        statusEl.className = 'export-status active success';
                        statusEl.textContent = `‚úÖ ${this.getVideoTypeName(videoType)}ÂØºÂá∫ÊàêÂäüÔºÅ`;
                    }
                    
                    // ÊÅ¢Â§çÂä®ÁîªÁä∂ÊÄÅ
                    if (wasPlaying) {
                        this.startAnimation();
                    }
                    
                } catch (error) {
                    console.error('ÂØºÂá∫Â§±Ë¥•:', error);
                    statusEl.className = 'export-status active error';
                    statusEl.textContent = '‚ùå ÂØºÂá∫Â§±Ë¥•: ' + error.message;
                } finally {
                    exportBtn.disabled = false;
                    
                    // 3ÁßíÂêéÈöêËóèÁä∂ÊÄÅ
                    setTimeout(() => {
                        statusEl.classList.remove('active');
                    }, 3000);
                }
            },
            
            // Ëé∑ÂèñËßÜÈ¢ëÁ±ªÂûãÂêçÁß∞
            getVideoTypeName(videoType) {
                const names = {
                    'animation': '‰∏ªÂä®ÁîªËßÜÈ¢ë',
                    'displacement': '‰ΩçÁßªÂõæËßÜÈ¢ë',
                    'velocity': 'ÈÄüÂ∫¶ÂõæËßÜÈ¢ë',
                    'energy': 'ËÉΩÈáèÂõæËßÜÈ¢ë',
                    'resonance': 'ÂÖ±ÊåØÊõ≤Á∫øËßÜÈ¢ë'
                };
                return names[videoType] || videoType;
            }
        };

        // ÂàùÂßãÂåñ
        document.addEventListener('DOMContentLoaded', function() {
            console.log('ÊåØÂä®Á≥ªÁªüÁªºÂêàÊ®°ÊãüÂô®Âä†ËΩΩ‰∏≠...');
            
            simpleSim.init();
            dampedSim.init();
            forcedSim.init();
            
            // Á™óÂè£Ë∞ÉÊï¥‰∫ã‰ª∂
            window.addEventListener('resize', () => {
                if (currentSimulator === 'simple') {
                    simpleSim.handleResize();
                } else if (currentSimulator === 'damped') {
                    dampedSim.handleResize();
                } else {
                    forcedSim.handleResize();
                }
            });
            
            console.log('ÊåØÂä®Á≥ªÁªüÁªºÂêàÊ®°ÊãüÂô®ÂàùÂßãÂåñÂÆåÊàêÔºÅ');
        });
    </script>
</body>
</html>
